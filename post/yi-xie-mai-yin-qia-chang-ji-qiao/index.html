<html>

<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>一些卖淫卡常技巧 | 一个 OIer 的个人修养</title>

<link rel="shortcut icon" href="https://明天动手.top/favicon.ico?v=1753617641627">

<link href="https://明天动手.top/media/pure/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://明天动手.top/styles/main.css">

<script src="https://明天动手.top/media/pure/highlight.min.js"></script>
<script src="https://明天动手.top/media/dockerfile.min.js"></script>
<script src="https://明天动手.top/media/dart.min.js"></script>




        <link rel="stylesheet" href="https://明天动手.top/media/pure/katex.min.css">
        <script defer src="https://明天动手.top/media/pure/katex.min.js"></script>
        <script src="https://明天动手.top/media/pure/cursor-effects.js"></script>
        
</head>

<body>
    <div class="main gt-bg-theme-color-first">
        <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            一个 OIer 的个人修养
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/friends" class="menu gt-a-link">
                    友链
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/gong-ju-xiang" class="menu gt-a-link">
                    工具箱
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1753617641627"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

            <div class="post-container">
                <div class="post-detail gt-bg-theme-color-second">
                    <article class="gt-post-content">
                        <h2 class="post-title">
                            一些卖淫卡常技巧
                        </h2>
                        <div class="post-info">
                            <time class="post-time gt-c-content-color-first">
                                · 2024-06-19 ·
                            </time>
                            
                                <a href="https://明天动手.top/tag/XQCTepZve/" class="post-tags">
                                    # 笔记
                                </a>
                                
                        </div>
                        <div class="post-content">
                            <p>在数学和物理里，常数是指在一定语境下不变的量。万有引力常数（记作G）是一个包含在对有质量的物体间的万有引力的计算中的实验物理常数。而在我们数学课堂上讲多项式的时候，一般情况下一个项的系数（或零次项）就是常数。</p>
<p>而在评价一个算法好坏时，通常用其大 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span> 来衡量其上界。有一种算法的时间复杂度是另一种的大 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">Θ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Θ</span></span></span></span>，但是其在具体实现时可能稍慢于另一种。而在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>→</mo><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">n \to \infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span> 时，其他的项都很小可以忽略不计，两者之间只有<strong>常数</strong>差距。</p>
<p>在 OI 中，<strong>常数</strong>是指用渐进学算出来一样的情况下，用来衡量一个算法速度快慢的概念。由此看来，我们口中的<strong>常数</strong>是个相对的概念。我们只会说这种算法的常数小于另外一种，也不会像数学里那样具体求出这个数的值。</p>
<p>数据范围较大时，快速读入一个十进制整数是个令人抓耳挠腮的问题。就比如使用下面的代码输入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding="application/x-tex">10^6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span> 的整数个时，我们很有可能会出现 TLE。</p>
<pre><code class="language-c++">int main(){
    std::cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++) std::cin&gt;&gt;a[i];
    return 0;
}
</code></pre>
<p>我们平常用 <code>std::cin</code> 时，会发现非常慢，比几乎所有 C 元老都慢。因为有很多码农喜欢把 <code>cin</code>、<code>cout</code> 和 <code>scanf</code>、<code>printf</code> 一起混用，所以人们将流与 <code>stdio</code> 捆绑在了一起缓存用了很多时间。</p>
<p>所以我们可以使用 <code>ios::sync_with_stdio(false)</code> 让 <code>cin</code> 与 <code>printf</code> 使用不同的缓冲区，也就是让两者使用不同的缓冲区。但是这样后 <code>cin</code> 和 <code>cout</code> 还是默认被绑定的，<code>cout</code> 在每次输入前要 <code>flush</code>（同步 <code>streambuf</code> 和 <code>cout</code> 记住的输出）。<code>cin.tie(nullptr)</code> 可以关闭这个特性，再一次提速。 同理，把 <code>endl</code> 替换为 <code>\n</code> 也能通过减少 <code>flush </code>加速。</p>
<p>通过会议中考题目 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mrow><mi>a</mi><mi>b</mi><mi>c</mi></mrow><mo stretchy="true">‾</mo></mover><mo>=</mo><mn>100</mn><mi>a</mi><mo>+</mo><mn>10</mn><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">\overline{abc}=100a+10b+c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89444em;vertical-align:0em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.89444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span></span></span><span style="top:-3.81444em;"><span class="pstrut" style="height:3em;"></span><span class="overline-line" style="border-bottom-width:0.04em;"></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，而 <code>getchar()</code> 是从 <code>stdin</code> 读取下一个字符（也就是从左往右看你的输入）。所以每当读入下一个字符就要执行一遍类似于秦九韶算法的过程，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mn>10</mn><mi>a</mi><mo>+</mo><mi>c</mi><mo>−</mo><mn>48</mn></mrow><annotation encoding="application/x-tex">a=10a+c-48</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">8</span></span></span></span>。在读入这个数之前，可能有一些别的符号。有些数前面有负号，因此<br>
要跳过除了负号以外的字符，在有负号时做好判断即可。</p>
<ul>
<li>经测试把 <code>isdigit</code> 拆成两个比较会变快。</li>
<li>你可以把 <code>c-48</code> 换成 <code>c&amp;15</code>。</li>
<li>但是不要把 <code>10a</code> 换成 <code>(a&lt;&lt;3)+(a&lt;&lt;1)</code> ，因为编译器会自动优化。</li>
<li>如果题目的数据范围是非负整数的话，可以去掉读入非字符时判断之前的符号的代码。</li>
</ul>
<p>我们一般使用 <code>getchar()</code> 读入一个字符。有没有更快的方法？</p>
<ul>
<li><code>fread()</code> 可以一次读入 <code>SIZE</code> 个字符到缓冲数组内，用法：<code>fread(ibuf,1,SIZE,stdin)</code>。</li>
<li>读入时遇到 <code>EOF</code> 或读完才会执行后续代码。</li>
<li>可以用这个方法直接代替：</li>
</ul>
<pre><code class="language-c++">#define getchar() (p1==p2&amp;&amp;(p2=(p1=inf)+fread(ibuf,1,1&lt;&lt;15,stdin),p1==p2)?EOF:*p1++)
char ibuf[1&lt;&lt;15],*p1,*p2;
</code></pre>
<p>我们的 <code>putchar()</code> 是只能一个一个地输出，而 <code>printf</code> 可输整数但很慢。可把原数拆成十进制位，再从高到低依次输出。优化方式同快读，不过这样做还是较慢，甚至有时比 <code>printf</code> 还慢。同快读，可以用 <code>fwrite</code> 优化，好像用 <code>puts()</code> 或者 <code>fputs()</code> 也较快。</p>
<p><code>streambuf</code> 就是 <code>cin</code> 、<code>cout</code> 内部那个缓冲区。快读前加上 <code>static streambuf*isbuf = cin.rdbuf()</code>，快写类似。<code>fread(ibuf,1,SIZE,stdin)</code> 变成 <code>isbuf-&gt;sgetn(ibuf, SIZE)</code>。<code>putchar(C)</code> 变成 <code>osbuf-&gt;sputc(C)</code>，其他写法和 <code>fread/fwrite</code> 光速 IO 写法一样。</p>
<p>用了 <code>fwrite</code> 等不要在程序结束前 <code>fclose(stdout)</code>。</p>
<ul>
<li>取消同步后千万不要混用 C 和 C++ 输入和输出，也不要先写取消同步再 <code>freopen</code>。</li>
<li>最好也不要混用 <code>scanf</code>。</li>
<li>在输入输出交互题里面，用了 <code>cin.tie(nullptr)</code> 你需要手动 <code>flush</code>。</li>
<li>在使用 <code>fread</code> 系列 /<code>streambuf</code> 时,你需要多按几下 <code>ctrl+z</code>，而且有的机器不支持控制台<br>
输入。</li>
<li>写文件快输要考虑到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 和 <code>INT_MIN</code>。</li>
<li>注意快读会从 <code>stdin</code> 中抽掉数字后的一个字符，所以读入一些像 <code>2+3i</code> 之类的只能特判。</li>
</ul>
<p>有符号类型的整数的范围是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi mathvariant="normal">−</mi><msup><mn>2</mn><mrow><mtext>位数</mtext><mi mathvariant="normal">−</mi><mn>1</mn></mrow></msup><mo separator="true">,</mo><msup><mn>2</mn><mrow><mi mathvariant="normal">位</mi><mi mathvariant="normal">数</mi><mi mathvariant="normal">−</mi><mn>1</mn></mrow></msup><mi mathvariant="normal">−</mi><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[−2^{\text{位数}−1}, 2^{位数−1}−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0913309999999998em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">位数</span></span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">位</span><span class="mord cjk_fallback mtight">数</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。而我们在读入一个整数时，是先记录前面有没有负号，再计算其绝对值的，这样就会导致他们在读入 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">−</mi><msup><mn>2</mn><mtext>位数−1</mtext></msup></mrow><annotation encoding="application/x-tex">−2^{\text{位数−1}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.924661em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">位数</span><span class="mord mtight">−1</span></span></span></span></span></span></span></span></span></span></span></span></span>时，会导致其绝对值溢出。而有符号数的溢出是未定义的，在正式比赛时用了可能造成意想不到的后果，可以通过特判负号或开 <code>unsigned</code> 来解决这个问题。</p>
<p>当你定义一个整型变量时：</p>
<ul>
<li>如果它是有符号的的话，会留出一位作为符号位，但有些时候我们只有非负值。</li>
<li>并且，使用无符号类型比有符号类型更快。</li>
<li>因此，我们可以使用无符号整数。</li>
</ul>
<p>一般情况下，位运算很快，因为是计算机所擅长的。加法很快，乘法较快，除法和取模一般较慢，因此在保证不溢出的情况下尽量少用取模。因为运算结果的范围，加减法的取模可以判断是否在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mtext>模数</mtext><mo>)</mo></mrow><annotation encoding="application/x-tex">[0,\text{模数})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord cjk_fallback">模数</span></span><span class="mclose">)</span></span></span></span> 之中，若出范围则进行加减调整。<code>&amp;&amp;</code> 和 <code>||</code> 是短路运算符（如果左值已经可以确定表达式的值就不用计算右值），而 <code>&amp;</code>、<code>|</code> 不是。</p>
<p>不过，编译器不是蒟蒻，它也会自己优化你写的代码。比如，在你打出 <code>n&lt;&lt;1</code>、<code>n*2</code> 时，编译器可能会自动帮你优化成一样的。因此，写 <code>n*10</code>（快读）时不需要画蛇添足地写成 <code>(n&lt;&lt;3)+(n&lt;&lt;1)</code>。对于大多数整数运算，即使不开 O2 优化编译器也会给你优化，比如 <code>/2</code>。但是浮点数不一样，如 <code>/2</code> 最好写成 <code>*0.5</code>。不过，当运算符两端都是变量时，编译器一般会不知所。</p>
<p>永远不要用 <code>bool</code>！！！状压时我们经常用整数来与集合在一定范围内一一映射，因为方便用数组下标访问。但这样没有充分利用每一位，<code>bitset</code> 可以把 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>8</mn></mrow><annotation encoding="application/x-tex">8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span> 二进制位的信息压进一个字节里，还支持位运，因此其常数极小（约为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>/整型位数）。</p>
<p>将一个循环中的语句展开成多条，提高代码的并行性，其原理是 CPU的乱序执行。注意各平行语句不能互相影响，否则虽然会快一点，但是没有真正展开那么快。一般来讲循环展开6~8层效果最佳，否则会让寄存器溢出，但是循环展开的缺陷就在于破坏了代码结构。</p>
<p>举一个例子：</p>
<pre><code class="language-c++">#include&lt;iostream&gt;
int n,ans;
int main(){
	std::cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
    	ans+=i;
	}
	std::cout&lt;&lt;ans&lt;&lt;'\n';
    return 0;
}
</code></pre>
<p>在展开时候就是这样的：</p>
<pre><code class="language-c++">#include&lt;iostream&gt;
int n,ans;
int main(){
	std::cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i+=4){
    	ans+=i;
    	if(i+1&lt;=n) ans+=i+1;
    	if(i+2&lt;=n) ans+=i+2;
    	if(i+3&lt;=n) ans+=i+3;
	}
	std::cout&lt;&lt;ans&lt;&lt;'\n';
    return 0;
}
</code></pre>
<p>缓存存了下一级存储器的部分内容。我们要提高其命中（在这一级缓存内能找到）率，因为许多码农的程序都喜欢访问已访问位置附近的值。因此，存储器更乐意服务有时间局部性、空间局部性的访问。所以，我们访问数组尽量使得步⻓为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>1</mn><mtext>先枚举的较大维度</mtext></mfrac></mrow><annotation encoding="application/x-tex">\dfrac{1}{\text{先枚举的较大维度}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">先枚举的较大维度</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>、尽可能多地开能挤得进的数组（有时间局部性），就可以让卡进一级缓存。</p>
<p>然而，内存并不会随机化，它是根据内存的后几位确定编号的。所以，我们要避免使⽤步⻓为较⼤的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 的幂的访问模式，否则容易引起缓存冲突。在状态压缩动态规划、使⽤⾼维数组时很重要解决⽅法：把数组稍<br>
微开⼤⼀些。</p>
<p>递归要存储当前状态，因此就要花很长时间，而且可能莫名因爆栈而运行错误。如果要用，尽量不要传太多参，用全局变量。</p>
<p>关于一些其他的情况，<code>register</code> 和 <code>inline</code> 就不要使用了，因为新版会被编译器忽略。听说三目运算符、<code>switch case</code> 比 <code>if</code> <code>else</code> 分支快，但好像有的编译器会把<s>二郎神</s>三目运算符和 <code>if</code> <code>else</code> 优化成一样的。</p>
<p>一般为了方便，常用快速幂来求逆元。然而因为指数常为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>998244353</mn></mrow><annotation encoding="application/x-tex">998244353</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">8</span><span class="mord">2</span><span class="mord">4</span><span class="mord">4</span><span class="mord">3</span><span class="mord">5</span><span class="mord">3</span></span></span></span>，其满足 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>199</mn><mo>×</mo><msup><mn>2</mn><mn>23</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">199\times 2^{23}+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">9</span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的形式，因此 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>998244351</mn></mrow><annotation encoding="application/x-tex">998244351</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">9</span><span class="mord">8</span><span class="mord">2</span><span class="mord">4</span><span class="mord">4</span><span class="mord">3</span><span class="mord">5</span><span class="mord">1</span></span></span></span> 二进制表示低位很多 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，意味着需要乘很多次。可以换用扩欧（一般跑不满，但用斐波那契数列相邻两项作为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span> 能卡满，不过一般情况下模数不会是斐波那契数列的一项（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>233</mn></mrow><annotation encoding="application/x-tex">233</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">3</span><span class="mord">3</span></span></span></span> 等例外））。</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>C</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><msub><mi>A</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>×</mo><msub><mi>B</mi><mrow><mi>k</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{i,j}=\sum_{k=1}^m A_{i,k}\times B_{k,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05017em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。按我们平常的思维，显然会枚举矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi></mrow><annotation encoding="application/x-tex">C</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span> 的每一个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span> 的位置，再枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>。可是我们这样的话，对矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>（二位数组）的空间访问就不连续。我们可以用一次枚举 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i,k,j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>，这样每个矩阵都可以利用空间访问的局部性。</p>
<p>前置的 <code>++</code> 即先 <code>+1</code>，在返回值，后置的 <code>++</code> 即变量 <code>+1</code> 但返回原来的值（<code>--</code> 同理）。因此，如果使用后置 <code>++</code>，每次都要储存之前的值再返回。所以，我们就可以用前置的 <code>++</code>，加快访问的速度。然而，有的时候如果没有用返回值时，整型变量会被编译器直接给你优化成一样的。但是，<code>stl</code> 里面容器的迭代器不是编译器内置的，因此后置 <code>++</code> 还是会计算出一个返回值（即使不必要），所以前置 <code>++</code> 优化得很大。</p>
<p>关于 SPFA，他（避讳）了。不过，你如果不担心你写哈希被卡的话，你也可以写 SPFA。可以加些优化，如酸辣粉（SLF）优化（如果新点距离小于队头距离就插入队首，否则插入队尾）等等。注意：如果不是队列或者dijkstra那种一出队就决定的话可以把时间复杂度卡成指数。不过，判负环、差分约束时应该没人敢卡。SPFA 判负环时可以记录每个点的入队次数或最短路的边数来加快判负环的速度；也可以把 SPFA 的队列换成栈等等。</p>

                        </div>
                        
                        <img src="http://img.hongyoubizhi.com/picture/pages/original/2022/08/31/14/102116047_p0.jpg" height="300">
                    </article>
                </div>

                
                    <div class="next-post">
                        <div class="next gt-c-content-color-first">下一篇</div>
                        <a href="https://明天动手.top/post/feng-zhuang-pu-tong-kuai-du/" class="post-title gt-a-link">
                            封装快读
                        </a>
                    </div>
                    

                        

                                

                                                                
                                                                    <script src='https://明天动手.top/media/pure/Valine.min.js'></script>

<style>
	div#vcomments{
		width: 100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style>


	<div id="vcomments"></div>

<script>
	new Valine({
		el: '#vcomments',
		appId: 'VwREBewhoRVBs0cw8hL9zbGr-gzGzoHsz',
		appKey: 'xhO1EyZv0GYpZWiLMOdky03s',
		avatar: 'retro',
		pageSize: 5,
		recordIp: true,
		placeholder: 'What can I say ?',
		visitor: false,
	});
</script>

                                                                        

                                                                            <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">给岁月以文明，而不是给文明以岁月。</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Explosion！！！
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://明天动手.top/atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

            </div>
    </div>
</body>

</html>