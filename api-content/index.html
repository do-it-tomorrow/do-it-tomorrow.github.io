{"posts":[{"title":"[CF1610D] Not Quite Lee  的题解","content":"假设长度为 aia_iai​ 的连续的序列的第一项为 xix_ixi​，那么因为易得 si=ai⋅[xi+(xi+ai−1)]2s_i=\\cfrac{a_i\\cdot[x_i+(x_i+a_i-1)]}{2}si​=2ai​⋅[xi​+(xi​+ai​−1)]​ 。 因为题目要求 ∑i=1msi=0\\sum_{i=1}^{m} s_i=0∑i=1m​si​=0，所以可以得到 ∑i=1mai⋅[xi+(xi+ai−1)]2=0\\sum_{i=1}^{m} \\cfrac{a_i\\cdot[x_i+(x_i+a_i-1)]}{2}=0∑i=1m​2ai​⋅[xi​+(xi​+ai​−1)]​=0。 即 ∑i=1mai⋅[2⋅xi+ai−1]2=0\\sum_{i=1}^{m} \\cfrac{a_i\\cdot[2\\cdot x_i+a_i-1]}{2}=0∑i=1m​2ai​⋅[2⋅xi​+ai​−1]​=0。 也就是 (∑i=1mai⋅(ai−1)2)+(∑i=1mai⋅xi)=0(\\sum_{i=1}^{m} \\cfrac{a_i\\cdot(a_i-1)}{2})+(\\sum_{i=1}^{m} a_i\\cdot x_i)=0(∑i=1m​2ai​⋅(ai​−1)​)+(∑i=1m​ai​⋅xi​)=0。 通过移项可以得到 ∑i=1mai⋅(ai−1)2=−∑i=1mai⋅xi\\sum_{i=1}^{m} \\cfrac{a_i\\cdot(a_i-1)}{2}=-\\sum_{i=1}^{m} a_i\\cdot x_i∑i=1m​2ai​⋅(ai​−1)​=−∑i=1m​ai​⋅xi​，所以左边就是一个常数。 根据贝祖定理，当且仅当 gcd⁡(a1,a2,⋯ ,am)∣∑i=1mai⋅(ai−1)2\\gcd(a_1,a_2,\\cdots,a_{m})\\mid \\sum_{i=1}^m \\cfrac{a_i\\cdot(a_i-1)}{2}gcd(a1​,a2​,⋯,am​)∣∑i=1m​2ai​⋅(ai​−1)​ 时有解，通过移项可以得到 2∣∑i=1mai⋅(ai−1)gcd⁡(a1,a2,⋯ ,am)2\\mid \\sum_{i=1}^m \\cfrac{a_i\\cdot(a_i-1)}{\\gcd(a_1,a_2,\\cdots,a_{m})}2∣∑i=1m​gcd(a1​,a2​,⋯,am​)ai​⋅(ai​−1)​。 假设 gcd⁡(a1,a2,⋯ ,am)=2t⋅(2k+1)\\gcd(a_1,a_2,\\cdots,a_{m})=2^t\\cdot (2k+1)gcd(a1​,a2​,⋯,am​)=2t⋅(2k+1) 其中 ttt 尽可能大且 kkk 为整数，那么设 ci=ai2tc_i=\\cfrac{a_i}{2^t}ci​=2tai​​。 将上式代入，得到 2∣∑i=1m2t⋅ci⋅(2t⋅ci−1)2t⋅(2k+1)2\\mid \\sum_{i=1}^m \\cfrac{2^t\\cdot c_i\\cdot(2^t\\cdot c_i-1)}{2^t\\cdot(2k+1)}2∣∑i=1m​2t⋅(2k+1)2t⋅ci​⋅(2t⋅ci​−1)​，由于这个式子是由 ∑i=1mai⋅(ai−1)gcd⁡(a1,a2,⋯ ,am)\\sum_{i=1}^m \\cfrac{a_i\\cdot(a_i-1)}{\\gcd(a_1,a_2,\\cdots,a_{m})}∑i=1m​gcd(a1​,a2​,⋯,am​)ai​⋅(ai​−1)​ 变形来的，所以一定是一个整数。 因为一个偶数除以一个奇数并不影响奇偶性，所以 2k+12k+12k+1 直接不看，即得到 2∣∑i=1mci⋅(2t⋅ci−1)2\\mid \\sum_{i=1}^m c_i\\cdot(2^t\\cdot c_i-1)2∣∑i=1m​ci​⋅(2t⋅ci​−1)。 当 t=0t=0t=0 时，等式恒成立，否则需满足 2∣∑i=1mci2\\mid \\sum_{i=1}^m c_i2∣∑i=1m​ci​。 因为 t=0t=0t=0 只会发生在选择的 mmm 个数中出现奇数，所以将奇数的情况单独讨论。 假设奇数有 nnn 个，偶数有 mmm 个，那么因为只要有奇数就可以，所以方案数为 (2a−1−1)⋅2b(2^{a-1}-1)\\cdot 2^b(2a−1−1)⋅2b。 对于 t≠0t\\ne 0t​=0 的情况，假设有 aaa 个 aia_iai​ 没有多余的 222，bbb 个有多余的 222，那么贡献为 2b⋅∑i=1⌊m/2⌋Ca2i2^b\\cdot \\sum_{i=1}^{\\lfloor m/2\\rfloor }C^{2i}_{a}2b⋅∑i=1⌊m/2⌋​Ca2i​。 因为 Cai=Ca−1i⋅Ca−1i−1C^i_a=C^i_{a-1}\\cdot C_{a-1}^{i-1}Cai​=Ca−1i​⋅Ca−1i−1​，所以贡献为 2b⋅∑i=1a−1Ca−1i2^b\\cdot\\sum_{i=1}^{a-1}C^i_{a-1}2b⋅∑i=1a−1​Ca−1i​，也就是 aaa 个元素的非空子集数量 2b⋅(2a−1−1)2^b\\cdot (2^{a-1}-1)2b⋅(2a−1−1)。 #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=2e5+5,mod=1e9+7; int n,s[N],sum,ans; int ksm(int a,int b){ int ans=1; while(b){ if(b&amp;1){ ans=ans*a%mod; } b&gt;&gt;=1; a=a*a%mod; } return ans; } int f(int x){ int ans=0; while(!(x&amp;1)){ ans++; x&gt;&gt;=1; } return ans; } signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n; for(int i=1,x;i&lt;=n;i++){ cin&gt;&gt;x; s[f(x)]++; } for(int i=1;i&lt;=30;i++){ sum+=s[i]; } ans=(ksm(2,n-sum)-1+mod)%mod*ksm(2,sum)%mod; for(int i=1;i&lt;=30;i++){ sum-=s[i]; if(s[i]&lt;2){ continue; } ans=(ans+ksm(2,sum)%mod*(ksm(2,s[i]-1)-1+mod)%mod)%mod; } cout&lt;&lt;ans&lt;&lt;'\\n'; return 0; } ","link":"https://doittomorrow.xyz/post/cf1610d-not-quite-lee-de-ti-jie/"},{"title":"[CF991E] Bus Number 的题解","content":"题目大意 给定一个全数字字符串 s1s1s1，假设数字 iii 出现了 aia_iai​ 次。 现在要求构造全数字字符串 s2s2s2，假设数字 iii 出现了 bib_ibi​ 次。 那么 bbb 满足一下要求 对于 i∈[0,9]i\\in[0,9]i∈[0,9]，bi≤aib_i\\le a_ibi​≤ai​ ai≠0a_i\\ne 0ai​​=0 时 bi≠0b_i\\ne 0bi​​=0 s21≠0s2_{1}\\ne 0s21​​=0 思路 首先需要明确如何求解一个字符串的全排列。 假设字符串 sss 长度为 nnn，其全排列个数为 f(s)f(s)f(s)。 如果 i,j∈[1,n],i≠ji,j\\in[1,n],i\\ne ji,j∈[1,n],i​=j 满足 si≠sjs_i\\ne s_jsi​​=sj​，那么 f(s)=n!f(s)=n!f(s)=n!。 因为对于第 iii 次选择时，在以前的选择中已经选择了 i−1i-1i−1 个元素，那么对于这次选择就只有 n−i+1n-i+1n−i+1 个元素可以选择了。 假设 gig_igi​ 表示选择了 iii 次的方案数，因为乘法原理，gi=gi−1⋅(n−i+1)g_i=g_{i-1}\\cdot (n-i+1)gi​=gi−1​⋅(n−i+1)。 所以 gn=f(s)=n×(n−1)×⋯×2×1g_n=f(s)=n\\times (n-1)\\times \\cdots \\times 2 \\times 1gn​=f(s)=n×(n−1)×⋯×2×1。 对于不满足 i,j∈[1,n],i≠ji,j\\in[1,n],i\\ne ji,j∈[1,n],i​=j 满足 si≠sjs_i\\ne s_jsi​​=sj​ 的情况，那么假设字符 iii 出现了 aia_iai​ 次。 f(s)=n!−∑i∈aai!f(s)=n!-\\sum_{i\\in a} a_i! f(s)=n!−i∈a∑​ai​! 因为将任意两个重复的元素交换得到的方案其实是一样的，所以需要将多余的方案减掉。 对于重复的可能性，其实就是对于这些重复的元素自己的看重顺序的全排列数量，所以就是 ai!a_i!ai​!。 具体的对于这道题目，因为 nnn 非常的小，可以使用 dfs 暴力枚举出所有字符串使用每一个元素的次数，那么答案就是所有元素的全排列减去以 000 作为开头的排列个数。 ans=(∑i=09ai)!∏i=09ai!−[(∑i=09ai)−1]!(a0−1)!⋅∏i=19ai!ans=\\cfrac{(\\sum_{i=0}^{9}a_i)!}{\\prod_{i=0}^{9}a_i! }-\\cfrac{[(\\sum_{i=0}^{9}a_i)-1]!}{(a_0-1)!\\cdot\\prod_{i=1}^{9}a_i! } ans=∏i=09​ai​!(∑i=09​ai​)!​−(a0​−1)!⋅∏i=19​ai​![(∑i=09​ai​)−1]!​ AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=20; int n,s[N],ans,f[N],jc[N]; char a[N]; void init(){ jc[0]=1; for(int i=1;i&lt;N;i++){ jc[i]=jc[i-1]*i; } } void dfs(int x){ if(x==10){ int tot=0; for(int i=0;i&lt;=9;i++){ tot+=f[i]; } int sum=jc[tot]; for(int i=0;i&lt;=9;i++){ sum/=jc[f[i]]; } if(f[0]&gt;0){ int num=jc[tot-1]/jc[f[0]-1]; for(int i=1;i&lt;=9;i++){ num/=jc[f[i]]; } sum-=num; } ans+=sum; return; } for(int i=1;i&lt;=s[x];i++){ f[x]=i; dfs(x+1); } if(!s[x]){ dfs(x+1); } } signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;a+1,n=strlen(a+1); init(); for(int i=1;i&lt;=n;i++){ s[a[i]-'0']++; } dfs(0); cout&lt;&lt;ans&lt;&lt;'\\n'; return 0; } ","link":"https://doittomorrow.xyz/post/cf991e-bus-number-de-ti-jie/"},{"title":"一些 OJ","content":"洛谷 不错的一个适合学习的社区。 一个美化代码 library OJ 一个又很多好体而且很硬核的 OJ。 虚拟评测 拥有各大 OJ 的账号和先进的爬虫技术。 hydro 一个很开放的平台。 codeforces 可以联系思维的高级平台。 一个翻译代码 atcoder 一个适合巩固基础的高级平台。 一个翻译代码+一个美化代码+一个统计代码 爆炸 OJ 原来还在的，现在被 hydro 接管了... 北大 OJ 有很多好题，很不错。 uoj 开源的一个 OJ。 ","link":"https://doittomorrow.xyz/post/test/"},{"title":"[ARC020C] A mod B Problem 的题解","content":"题目大意 将 lil_ili​ 个 aia_iai​ 依次拼接在一起，结果对 109+710^9+7109+7 取模。 思路 假设答案为 ansansans，那么递推的方程为 ans=ans⋅10⌊log⁡10ai⌋+aians=ans\\cdot 10^{\\lfloor\\log_{10}a_i\\rfloor}+a_ians=ans⋅10⌊log10​ai​⌋+ai​。 因为 lil_ili​ 有 10910^9109 进行模拟是不可行的，所以考虑使用矩阵快速幂加速递推。 [ansai]=[ansai]×[10⌊log⁡10ai⌋011]li\\begin{bmatrix} ans &amp; a_i\\end{bmatrix}=\\begin{bmatrix} ans &amp; a_i\\end{bmatrix} \\times \\begin{bmatrix} 10^{\\lfloor\\log_{10}a_i\\rfloor} &amp; 0\\\\1&amp;1\\end{bmatrix}^{l_i} [ans​ai​​]=[ans​ai​​]×[10⌊log10​ai​⌋1​01​]li​ AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=1e4+6; struct node{ int a[3][3]; node(){ memset(a,0,sizeof(a)); } }ans,aa; int n,mod,a[N],l[N]; node times(node x,node y){ node cnt; for(int i=1;i&lt;=2;i++){ for(int j=1;j&lt;=2;j++){ for(int k=1;k&lt;=2;k++) cnt.a[i][j]=(cnt.a[i][j]+x.a[i][k]*y.a[k][j])%mod; } }return cnt; }node ksm(int x){ while(x){ if(x&amp;1) ans=times(ans,aa); x&gt;&gt;=1; aa=times(aa,aa); }return ans; }int f(int x){ int cnt=0; while(x){ cnt++; x/=10; } x=1; for(int i=1;i&lt;=cnt;i++){ x*=10; } return x; } signed main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]&gt;&gt;l[i]; } cin&gt;&gt;mod; ans.a[1][1]=0; for(int i=1;i&lt;=n;i++){ ans.a[1][2]=a[i]%mod; aa.a[1][1]=f(a[i])%mod; aa.a[2][1]=aa.a[2][2]=1; ksm(l[i]); } cout&lt;&lt;ans.a[1][1]&lt;&lt;'\\n'; return 0; } ","link":"https://doittomorrow.xyz/post/arc020c-a-mod-b-problem-de-ti-jie/"},{"title":"[ARC111B] Reversible Cards 的题解","content":"题目大意 有 nnn 卡片在桌子上，每张卡牌正反两面分别有一个颜色。第 iii 牌的正面的颜色为 aia_iai​ ，背面为 bib_ibi​。 对于每张牌，可以选择正面或者背面朝上。所有可能的情况中出现的不同的颜色的数量的最大值。 思路 考虑建图，将 aia_iai​ 与 bib_ibi​ 连边。如果一个联通块内有环则整个联通块都可以选择，否则有 111 个点将被舍弃。 因为如果出现环的情况，换上的所有点都可以通过自己一侧的边被选择，而因为环上的点全部都自给自足了，所有从环外连到环内的点都可以由向环内连接的那条进行选择。 具体来说，假设一个联通块如图所示： 那么 1,2,3,4,51,2,3,4,51,2,3,4,5 号在环上的节点均可以通过环上的边 a,b,c,d,e\\texttt{a},\\texttt{b},\\texttt{c},\\texttt{d},\\texttt{e}a,b,c,d,e 进行选择。 而因为这些环上的节点均已经通过环上的边进行选择，那么 6,7,86,7,86,7,8 号节点就可以通过他们向环的方向连的边 f,g,h\\texttt{f},\\texttt{g},\\texttt{h}f,g,h 进行选择。 对于不存在环的情况，如下图： 8,2,3,4,5,6,78,2,3,4,5,6,78,2,3,4,5,6,7 号节点均可以通过 h,b,c,e,f,g,\\texttt{h},\\texttt{b},\\texttt{c},\\texttt{e},\\texttt{f},\\texttt{g},h,b,c,e,f,g, 进行选择。 而 111 号节点则无边可用，自然就被舍弃了。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=4e5+6; int n,m,ans,cnt,flag; bool vis[N]; vector&lt;int&gt; v[N]; void dfs(int x,int fa){ cnt++; for(int i:v[x]){ if(i!=fa&amp;&amp;vis[i]){ flag=0; } if(!vis[i]){ vis[i]=1; dfs(i,x); } } } signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;m; for(int i=1,x,y;i&lt;=m;i++){ cin&gt;&gt;x&gt;&gt;y; v[x].push_back(y); v[y].push_back(x); n=max({n,x,y}); } for(int i=1;i&lt;=n;i++){ if(!vis[i]){ vis[i]=1; flag=1,cnt=0; dfs(i,0); ans+=cnt-flag; } } cout&lt;&lt;ans&lt;&lt;'\\n'; return 0; } ","link":"https://doittomorrow.xyz/post/arc111b-reversible-cards-de-ti-jie/"},{"title":"[CF1067B] Multihedgehog 的题解","content":"题目大意 定义 kkk 阶刺猬树： 对于 111 阶刺猬树，其中一个点的度 ≥3\\ge3≥3，其它点的度均为 111。 对于 kkk 阶刺猬树，是在 k−1k−1k−1 阶刺猬树的基础上，把所有度为 111 的点替换成 111 阶刺猬树，并与原图相连。 给定 nnn 个点的树，判断是否是 kkk 阶刺猬树。 思路 对于任意 kkk 阶刺猬树，有性质： 假定 aaa 为原始 111 阶刺猬树的度 ≥3\\ge 3≥3 的节点，则 aaa 到所有叶子节点的距离均为 kkk。 而且只要满足此性质及为 kkk 阶刺猬树。 证明： 假设 aaa 为 111 阶刺猬树的度 ≥3\\ge 3≥3 的节点，那么所有的节点到 aaa 的距离均为 111。 222 阶刺猬树则将所有度为 111 的节点增加一层，及将 aaa 到叶子节点的距离增加 111。 对于 kkk 阶刺猬树，aaa 到叶子的节点均为 k−1k-1k−1 阶刺猬树到叶子的节点的距离加 111，所以 kkk 阶刺猬树中 aaa 到叶子节点的距离为 kkk。 相对的，将所有的叶子节点都向父节点移动，那么如果所有的移动经过 kkk 次移动，到最后在一个节点汇合那么这棵树就是 kkk 阶刺猬树。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=2e5+6; int n,k,du[N]; bool vis[N]; vector&lt;int&gt; v[N]; queue&lt;int&gt; q[2]; signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n&gt;&gt;k; if(k&gt;n){ cout&lt;&lt;&quot;No\\n&quot;; exit(0); } for(int i=1,x,y;i&lt;n;i++){ cin&gt;&gt;x&gt;&gt;y; v[x].push_back(y); v[y].push_back(x); du[x]++,du[y]++; } for(int i=1;i&lt;=n;i++){ if(du[i]==1){ q[1].push(i); vis[i]=1; // cout&lt;&lt;i&lt;&lt;' '; } } // cout&lt;&lt;'\\n'; // exit(0); for(int i=1;i&lt;k;i++){ while(!q[i%2].empty()){ int x=q[i%2].front(); q[i%2].pop(); for(int j:v[x]){ if(vis[j]){ continue; } if(du[j]&lt;=3){ cout&lt;&lt;&quot;No\\n&quot;; exit(0); } // cout&lt;&lt;j&lt;&lt;' '; vis[j]=1; q[(i+1)%2].push(j); } } // cout&lt;&lt;'\\n'; } int cnt=0,p; for(int i=1;i&lt;=n;i++){ if(!vis[i]){ cnt++; p=i; if(du[i]&lt;3){ cout&lt;&lt;&quot;No\\n&quot;; exit(0); } } } if(cnt==1&amp;&amp;q[k%2].size()==v[p].size()){ cout&lt;&lt;&quot;Yes\\n&quot;; } else{ cout&lt;&lt;&quot;No\\n&quot;; } return 0; } ","link":"https://doittomorrow.xyz/post/cf1067b-multihedgehog-de-ti-jie/"},{"title":"[AGC060B] Unique XOR Path 的题解","content":"题目大意 有一个 n×mn\\times mn×m 的网格，每个网格可以填 000 到 2k−12^k-12k−1 范围内的数字。现在从左上角走到右下角，每次可以选择往右边或往下走一步。如果路径上所有数字异或和为 000，称这样的路径为好路径。给定一条路径 sss，D\\texttt{D}D 表示往下走，R\\texttt{R}R 表示往右走。问，是否存在一个网格，使得这条路径 sss 是唯一的好路径。 思路 考虑用最少的数字填完整个表格，假设数字范围为 000 到 2t−12^t-12t−1，只要 t≤kt\\le kt≤k，就满足情况，否则不满足情况。 对于给定的路线 sss，异或和为 000，可以将路径上所有位置全部设置为 000。 考虑在路线 sss 变化 111 步的路线，也就是拐角处。为了让这些路线异或和不为 000，分别填 20,21,23⋯2^0,2^1,2^3\\cdots20,21,23⋯，同时在同一条斜线上填同样的数字，其余位置填 000。这样保证你只要走了路线 sss 之外的线路，在最终的异或和上都会出现新的 111。 但这样不是最优的，可以发现，如果出现连续的 222 个拐弯，222 个拐角可以填相同的数字。 同理可以模拟出 333 个连续的拐角需要 222 个不同的数字， 444 个连续的拐角需要 222 个不同的数字，如果有 xxx 个连续的拐角，那么 x/2x/2x/2 个不同的数组。 时间复杂度为 O(T(n+m))O(T(n+m))O(T(n+m))。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=105; int n,m,k; char a[N]; void solve(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;a+1; for(int i=1;i&lt;n+m-2;i++) if(a[i]!=a[i+1]) i++,k--; if(k&gt;=0) cout&lt;&lt;&quot;Yes\\n&quot;; else cout&lt;&lt;&quot;No\\n&quot;; } signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); int T; cin&gt;&gt;T; while(T--){ solve(); } return 0; } ","link":"https://doittomorrow.xyz/post/agc060b-unique-xor-path-de-ti-jie/"},{"title":"[CF771B] Bear and Different Names 的题解","content":"思路 首先假设所有的名字都是不一样的，所以在遇到 Yes\\texttt{Yes}Yes 的时候就不需要进行处理。 当遇到 No\\texttt{No}No 的时候，可以直接假设 namei+k−1=nameiname_{i+k-1}=name_{i}namei+k−1​=namei​。这样假设有一个好处，因为当在访问 namei+1name_{i+1}namei+1​ 的时候，nameiname_inamei​ 就不会被考虑了，所以即使是 Yes\\texttt{Yes}Yes 也不会影响。 注意：翻译并没有翻译出名字的长度 lenlenlen，应该满足 len∈[1,10]len\\in[1,10]len∈[1,10]。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=100; int n,k; char c[N]; vector&lt;char&gt; ans[N]; signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++){ ans[i].push_back(i%26+'A'); ans[i].push_back((i+i/26)%26+'a'); } for(int i=1;i&lt;=n-k+1;i++){ cin&gt;&gt;c; if(c[0]=='N') ans[i+k-1]=ans[i]; } for(int i=1;i&lt;=n;i++){ for(char j:ans[i]){ cout&lt;&lt;j; } cout&lt;&lt;' '; } return 0; } ","link":"https://doittomorrow.xyz/post/cf771b-bear-and-different-names-de-ti-jie/"},{"title":"[CF1178D] Prime Graph 的题解","content":"题目大意 构造一个简单无向图，是所有的有度的点的度都是质数而且总共的边的数量的个数是质数。 思路 因为需要让所有的入度都为质数，所以我们可以找到两个相邻的质数 2,32,32,3，因为这样即使增加了一条边那么这个节点的度也是质数。 先将这个图构成一个巨大的环，接着如果所有的边数并不是质数，那么就随便找两个不相邻的点连边。 因为在 200020002000 以内，质数都是十分密集的，所以即使是最坏的情况，那么大于 2⋅n2\\cdot n2⋅n 最近的质数也不会超过 n/2n/2n/2，直接将相距很远的点连边就可以了。 AC Code #include&lt;bits/stdc++.h&gt; using namespace std; const int N=1005; int n,a[N],s; bool ck(int x){ for(int i=2;i*i&lt;=x;i++) if(x%i==0) return 0; return 1; } signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n; while(!ck(s+n)) s++; cout&lt;&lt;n+s&lt;&lt;'\\n'; for(int i=1;i&lt;=n;i++) cout&lt;&lt;i&lt;&lt;' '&lt;&lt;((i+1&gt;n)?(i+1-n):(i+1))&lt;&lt;'\\n'; for(int i=1;i&lt;=s;i++) cout&lt;&lt;i&lt;&lt;' '&lt;&lt;((i+n/2&gt;n)?(i+n/2-n):(i+n/2))&lt;&lt;'\\n'; return 0; } ","link":"https://doittomorrow.xyz/post/cf1178d-prime-graph-de-ti-jie/"},{"title":"[CF1538F] Interesting Function 的题解","content":"题目大意 给定两个正整数 l,rl, rl,r，将 lll 不断加 111 直到 l=rl = rl=r，求出这一过程中 lll 发生变化的位数总数。 1≤l&lt;r≤1091 \\le l &lt; r \\le 10^91≤l&lt;r≤109。 思路 假设从 lll 处理到 rrr 变化的次数为 f(l,r)f(l,r)f(l,r)。 因为直接求解出 f(l,r)f(l,r)f(l,r) 十分困难，所以可以通过求出 f(0,l)f(0,l)f(0,l) 和 f(0,r)f(0,r)f(0,r) 最后做差得到。 假设一个数为 xxx 那么从 000 一直变化到 xxx 对于各位变化的次数就是 xxx。 因为从 000 增加的 xxx 一共增加了 xxx 次。 而每当他增加一次，这个数的个位就会变化一次。 考虑从后向前数第 kkk 为，假设增加一次为 10k−110^{k-1}10k−1，那么随着每增加一次，第 kkk 位就会变化一次。 因为走后会变成 xxx，所以第 kkk 位一共会变换 ⌊x/10k−1⌋\\lfloor x/10^{k-1}\\rfloor⌊x/10k−1⌋。 f(0,l)=∑i=0(log⁡10l)−1⌊l/10i⌋f(0,l)=\\sum _{i=0}^{(\\log_{10}l)-1} \\lfloor l/{10^i}\\rfloor f(0,l)=i=0∑(log10​l)−1​⌊l/10i⌋ AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=50; char a[N],b[N]; void solve(){ int ans=0; cin&gt;&gt;a+1&gt;&gt;b+1; int n=strlen(a+1),m=strlen(b+1); for(int i=1,x=0;i&lt;=n;i++){ x=x*10+a[i]-48; ans-=x; } for(int i=1,x=0;i&lt;=m;i++){ x=x*10+b[i]-48; ans+=x; } cout&lt;&lt;ans&lt;&lt;'\\n'; } signed main(){ int T; cin&gt;&gt;T; while(T--){ solve(); } return 0; } ","link":"https://doittomorrow.xyz/post/cf1538f-interesting-function-de-ti-jie/"},{"title":"[ABC206E] Divide Both 的题解","content":"题目大意 求出从 lll 至 rrr 中满足以下条件的 (x,y)(x,y)(x,y) 的个数。 gcd⁡(x,y)≠1\\gcd(x,y) \\ne 1gcd(x,y)​=1 且 gcd⁡(x,y)≠x\\gcd(x,y)\\ne xgcd(x,y)​=x 且 gcd⁡(x,y)≠y\\gcd(x,y)\\ne ygcd(x,y)​=y。 其中 1≤l≤r≤1061\\le l\\le r\\le 10^61≤l≤r≤106。 思路 正难则反，所以可以求出所有互质或者是相互倍数的 (x,y)(x,y)(x,y) 的对数，在将其减去所有的方案数就是答案。 设 sis_isi​ 表示满足 gcd⁡(a,b)=i\\gcd(a,b)=igcd(a,b)=i 而且 l≤a,b≤rl\\le a,b\\le rl≤a,b≤r 的数对 (a,b)(a,b)(a,b) 的个数。 因为 gcd⁡(a,b)=i\\gcd(a,b)=igcd(a,b)=i，所有有 a,b≥ia,b\\ge ia,b≥i，而且有 i∣a,i∣bi \\mid a,i \\mid bi∣a,i∣b。 假设满足 x∈[l,r]x\\in[l,r]x∈[l,r] 且 i∣xi \\mid xi∣x 的数量为 numnumnum,那么以 iii 为公因数的个数就是 num×(num−1)num\\times (num-1)num×(num−1)。 在以上的计算中 j≥ij\\ge ij≥i，且两数满足 i∣a,i∣bi \\mid a,i \\mid bi∣a,i∣b，j∣a,j∣bj \\mid a,j \\mid bj∣a,j∣b 的情况在计算 sis_isi​ 和 sjs_jsj​ 的时候都会计算，所以求出的公因数而不是最小公因数。为了求出 iii 为最大公因数时数对的个数，sis_isi​ 的计算方法应该向下面这样。 Si=(⌊r/i⌋−⌈l/i⌉)⋅(⌊r/i⌋−⌈l/i⌉−1)−∑j=⌈l/i⌉⌊r/i⌋Sj×iS_i=(\\lfloor r/i\\rfloor-\\lceil l/i \\rceil)\\cdot (\\lfloor r/i\\rfloor-\\lceil l/i \\rceil-1)-\\sum^{\\lfloor r/i\\rfloor}_{j=\\lceil l/i \\rceil}S_{j\\times i} Si​=(⌊r/i⌋−⌈l/i⌉)⋅(⌊r/i⌋−⌈l/i⌉−1)−j=⌈l/i⌉∑⌊r/i⌋​Sj×i​ 其中 s1s_1s1​ 表示 (x,y)(x,y)(x,y) 的 gcd⁡(x,y)=1\\gcd(x,y)=1gcd(x,y)=1 的数量，即 x,yx,yx,y 互质的数量。 对于是倍数的情况，枚举每一个数 iii，求出 j∈[l,r]j\\in[l,r]j∈[l,r] 且 i∣ji \\mid ji∣j 的所有的可能的 jjj 的数量，将答案减去就可以了。 因为如果 x∣yx \\mid yx∣y，那么在 x≠1,y≠1x\\ne 1,y\\ne 1x​=1,y​=1 的情况下，gcd⁡(x,y)=x\\gcd(x,y)=xgcd(x,y)=x 就不会与互质的情况重复计算。 时间复杂度为： O(r1+r2+r3+⋯+rr−2+rr−1+rr)=O(rlog⁡r)O(\\frac{r}{1}+\\frac{r}{2}+\\frac{r}{3}+\\cdots +\\frac{r}{r-2}+\\frac{r}{r-1}+\\frac{r}{r})=O(r \\log r) O(1r​+2r​+3r​+⋯+r−2r​+r−1r​+rr​)=O(rlogr) AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=1e6+6; int l,r,ans,s[N]; signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;l&gt;&gt;r; for(int i=r;i&gt;=1;i--){ int cnt=0,sum=0; for(int j=i;j&lt;=r;j+=i){ sum+=s[j]; if(j&gt;=l){ cnt++; } } s[i]=cnt*(cnt-1)/2-sum; } int cnt=0; for(int i=max(l,2ll);i&lt;=r;i++){ for(int j=2*i;j&lt;=r;j+=i){ cnt++; } } int n=r-l+1; int ans=n*(n-1)/2; cout&lt;&lt;(ans-(cnt+s[1]))*2; return 0; } ","link":"https://doittomorrow.xyz/post/abc206e-divide-both-de-ti-jie/"},{"title":"怎么卡飞哈希","content":"哈希 我们定义一个把字符串映射到整数的函数 fff，这个 fff 称为是 Hash 函数，我们希望这个函数 fff 可以方便地帮我们判断两个字符串是否相等，这就是哈希。 一般来说，哈希值都是使用 hashi=(base⋅hashi−1+si)%modhash_i=(base\\cdot hash_{i-1} +s_i)\\%modhashi​=(base⋅hashi−1​+si​)%mod 这个转移方程得到的。 在这个转移方程中，sss 为字符串，basebasebase 被称为底数，而 modmodmod 被称为模数。 生日悖论 如果一个班级有 232323 个人, 那么其中有两个人生日相同的概率超过 50%50\\%50%。因为这与自己的直觉相不符，所以被称为生日悖论。 其实出现这样问题的原因是并没有将“两个人的生日相同”和“有人和自己的生日相同”很好的区分开。 定义两人生日重复的情况叫同生缘。 假设一年有 NNN 天，那么不发生同生缘的概率可以写作： 1−P=∏i=1n−1(1−iN)1-P=\\prod_{i=1}^{n-1} (1-\\frac{i}{N}) 1−P=i=1∏n−1​(1−Ni​) 当 n≤Nn\\le Nn≤N 时，因为 (1−1N)n≈1−nN(1-\\frac{1}{N})^n\\approx 1-\\frac{n}{N}(1−N1​)n≈1−Nn​，所以 1−P≈∏i=1n−1(1−1N)i=(1−1N)n⋅(n−1)21-P\\approx \\prod_{i=1}^{n-1}(1-\\frac{1}{N})^i =(1-\\frac{1}{N})^{\\frac{n\\cdot(n-1)}{2}} 1−P≈i=1∏n−1​(1−N1​)i=(1−N1​)2n⋅(n−1)​ P=1−(1−1N)n⋅(n−1)2P=1-(1-\\frac{1}{N})^{\\frac{n\\cdot(n-1)}{2}} P=1−(1−N1​)2n⋅(n−1)​ 当 N=365N=365N=365 时，函数图像可点击此链接查看。 可以观察到，在 n=23n=23n=23 时 PPP 已经接近了 50%50\\%50%。 卡大质数哈希 假设模数为 109+710^9+7109+7，构造一个长度为 10510^5105 的字符串。 将这个数据带入上方函数，得到成功让字符串哈希冲突的概率为 P=0.993261715159P=0.993261715159P=0.993261715159。 所以直接使用随机构造的方式，在一般情况下就可以将其 hack。 #include&lt;bits/stdc++.h&gt; using namespace std; int main(){ printf(&quot;100000 20\\n&quot;); for(int i = 1;i &lt;= 100000;i++){ putchar(rand() % 26 + 'a'); } return 0; } 自然溢出 自然溢出，即 hash 数组使用 unsigned long long，也就是对于 2642^{64}264 取模。不光其值域不难出现哈希冲突，而且代码长度与常数都会大大减小，得到了不少的同学的青睐。 将 N=264,n=105N=2^{64},n=10^5N=264,n=105 带入上面的函数后，我们发现出现哈希冲突的可能性 PPP 无限接近与 000，所以使用生日攻击成功的可能性极小。 底数为偶数 可以构造全部为 a\\texttt{a}a 的子串和第一个为 b\\texttt{b}b 其余均为 a\\texttt{a}a 的两个长度相等且长苏大于 646464 的两个不一样的字符串。 因为底数的 646464 次方以上模 2642^{64}264 都是 000，所以即是两个字符串不同，他们的哈希值也都会一样。 底数为奇数 设一些串 sss，sis_isi​ 表示第 iii 个串，sis_isi​ 的哈希值为 hash(si)hash(s_i)hash(si​)。 定义 f(s)f(s)f(s) 为字符串 sss 内全部的 a\\texttt{a}a 都变为 b\\texttt{b}b，所有的 b\\texttt{b}b 都变成 a\\texttt{a}a。 定义 si+sjs_i+s_jsi​+sj​ 的意思为将 sjs_jsj​ 添加到 sis_isi​ 的末尾形成的新的字符串。 构造方法为：s1=as_1=\\texttt{a}s1​=a，si=si−1+f(si−1)s_i=s_{i-1}+f(s_{i-1})si​=si−1​+f(si−1​)，所以 ∣si∣=2i−1|s_i|=2^{i-1}∣si​∣=2i−1。 所以： hash(si)=hash(si−1)⋅base∣si−1∣+hash(f(si−1))=hash(si−1)⋅base2i−2+hash(f(si−1))hash(s_i)=hash(s_{i-1})\\cdot base^{|s_{i-1}|}+hash(f(s_{i-1}))=hash(s_{i-1})\\cdot base^{2^{i-2}}+hash(f(s_{i-1})) hash(si​)=hash(si−1​)⋅base∣si−1​∣+hash(f(si−1​))=hash(si−1​)⋅base2i−2+hash(f(si−1​)) hash(f(si−1))=hash(f(si−2))⋅base2i−2+hash(si−1)hash(f(s_{i-1}))=hash(f(s_{i-2}))\\cdot base^{2^{i-2}}+hash(s_{i-1}) hash(f(si−1​))=hash(f(si−2​))⋅base2i−2+hash(si−1​) hash(si)−hash(f(si−1))=(hash(si−1)−hash(f(si−2)))⋅base2i−2−(hash(si−1)−hash(f(si−2)))hash(s_i)-hash(f(s_{i-1}))=(hash(s_{i-1})-hash(f(s_{i-2})))\\cdot base^{2^{i-2}}-(hash(s_{i-1})-hash(f(s_{i-2}))) hash(si​)−hash(f(si−1​))=(hash(si−1​)−hash(f(si−2​)))⋅base2i−2−(hash(si−1​)−hash(f(si−2​))) hash(si)−hash(f(si−1))=(hash(si−1)−hash(f(si−2)))⋅(base2i−2−1)hash(s_i)-hash(f(s_{i-1}))=(hash(s_{i-1})-hash(f(s_{i-2})))\\cdot (base^{2^{i-2}}-1) hash(si​)−hash(f(si−1​))=(hash(si−1​)−hash(f(si−2​)))⋅(base2i−2−1) 因为希望产生哈希冲突，即 264∣hash(si)−hash(f(si))2^{64}\\mid hash(s_i)-hash(f(s_i))264∣hash(si​)−hash(f(si​))。 设 gig_igi​ 表示 hash(si)−hash(f(si))hash(s_i)-hash(f(s_i))hash(si​)−hash(f(si​))，那么 ggg 满足一下性质： gi=gi−1⋅(basei−2−1)g_i=g_{i-1}\\cdot (base^{i-2}-1) gi​=gi−1​⋅(basei−2−1) 因为每一个 base2i−1−1base^{2^{i-1}}-1base2i−1−1 都是偶数，所以是的 ggg 到达第 646464 项就可以 hack 了。 因为 base2i−1−1=(base2i−2−1)⋅(base2i−2+1)base^{2^{i-1}}-1=(base^{2^{i-2}}-1)\\cdot(base^{2^{i-2}}+1)base2i−1−1=(base2i−2−1)⋅(base2i−2+1) 且为一个偶数乘一个偶数, 而左边的可以继续递归下去, 所以到第 121212 位其实就可以 hack 了。 #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; char s[10000]; int main(){ cout&lt;&lt;(1&lt;&lt;12)+65&lt;&lt;' '&lt;&lt;(1&lt;&lt;11)&lt;&lt;'\\n'; int now=1; s[1]='a'; for (int i=1;i&lt;=12;i++){ for (int j=1;j&lt;=now;j++) s[now+j]=s[j]=='a'?'b':'a'; now&lt;&lt;=1; } for (int i=1;i&lt;=now;i++) printf(&quot;%c&quot;,s[i]); for (int i=1;i&lt;=65;i++) putchar('a'); return 0; } 参考文章 博客园 ","link":"https://doittomorrow.xyz/post/zen-me-qia-fei-ha-xi/"},{"title":"竞赛之美","content":"前面同学的演讲简直是精彩绝伦，让我赞叹不已并且自愧弗如，所以就请我狗尾续貂，让后面的同学不要有什么压力。 一位著名的玉树临风的英俊潇洒的风流倜傥的才貌双绝的精神明亮的人曾经说过： 做演讲就应该将观点一条一条的陈述出来，接着逐一论述并证明，这是一个理科生应有的逻辑思维，如果你还没有掌握这个能力，那你的竞赛就白学了。 为了让自己的竞赛学习不要被官方认定成为浪费时间，所以我分享的内容是竞赛的细节美和勇气美。 细节美 信竞是一个很容易让人误会的竞赛，因为不学这门课程的人几乎都不知道他的全称其实是信息学算法竞赛，而不是所谓的信息技术竞赛等等。这个名称十分重要，因为仅仅“算法”两字就说明了我们的学习范围仅仅是算法，对于什么其他的 AI、网络安全、游戏什么其他的都不是我们学习的范围。而使用信息技术竞赛这一名称就很有可能引起不必要的误会。由此可见，仅仅两字对结果的影响之大。 因为信竞的题目是机器评测的，并且让机器去检查代码是不是有错误，应不应该有过程分实在是太难了，所以如果输出的答案错了，就干脆就不给分得了。于是细节就在十分的重要了，因为只要数据量从 n=5n=5n=5 变为 n≤105n\\le 10^5n≤105，那么即使是极其细微的错误也会导致答案巨大的差异。 就比如信息技术竞赛，仅仅 666 个字就产生了如此巨大的影响，那么如果这个字数稍微变大一点比如 10510^5105。那么说不定从外星人入侵撞坏了卫星，到刘家玮的后槽牙上沾着菜叶子上网查需不需要看牙医都要处理了，毕竟这都是信息技术的应用嘛。 处理好细节说着轻飘飘的，但是真正的做到这一点却是很难的。在寒假的一次次模拟赛中，我明明想出了题目的做法，但是却因为细节，我屡屡失误。原本可以打到的前几名，但结果却是跌出前 101010，那种心里上的折磨是与极大的反差让我几近崩溃。在第 111 天的总结中，我问王老师怎么避免今天考试发生的情况，他语重心长的告诉我：模拟赛切记想到一半就想当然了，一定要全部分析一遍，确保无误。 于是在第二天的模拟赛我怀着满满的信心。但是在钻研了很久这些神奇的题目之后，时间已经流流失殆尽了。所以我将代码草草的写出来，简单的改一改就结束了，于是反馈也就草草的。于是在第 222 天的总结里我就又问王老师怎么避免今天考试发生的情况，他语重心长的直接将昨天的话重复了一遍：模拟赛切记想到一半就想当然了，一定要全部分析一遍，确保无误。 第 333 天的模拟赛仿佛为了讽刺王老师的敷衍一般，巧合的又出现了许多神奇的小问题，在第 333 天的总结中为了防止王老师继续复制上一次的回复，我详细的写到：怎么避免今天考试发生的情况呢？（建议不要在回答：先想清楚了再写）。或许是王老师看出了我的不满，于是义正言辞的回复了 999 个大字：“多犯几次就好了”。 虽然我当时认为这只是王老师在调侃我，但是现在回想战胜细心的方法不就这两点。对于第一种方法，我觉得可以凝练一下，也就是：菜就多练。而后面的的方案让我想到了沈腾在《飞驰人生 2》中的一句台词： 战胜恐惧的方法只有两种，分别是远离恐惧和反复的经历恐惧。 我想关于细节也是这样，因为我们做事永远都不能远离细节，所以我们就只能反复的经历没有处理好细节的过程，获取足够的经验方能走出这个困境。虽然不知道是这两个方法非常的有用，但是我在开学后的几次模拟赛都取得了不错的成绩。 叛逆是人类的本性，往往越是别人强迫你做的事即是对你有好处你也并不会心甘情愿的完成。但是一旦这件事情是你自发的去完成的，那么你就会爆发出强大的动力，毕竟正常人永远都不能长期战胜自己的本能。 信息竞赛用自己的方式，让我自己充分的认识到了注意细节的重要性，我认为这就是信息竞赛的细节美。 勇气美 但是如果将目光仅仅局限在信息竞赛之上，我想可能与本次演讲的题目有些矛盾，毕竟这次演讲的题目是“竞赛之美”而不是“信息竞赛之美”，这就充分的的体现了细节的重要性。 马伯庸的中篇小说《长安的荔枝》主要讲了一个名为李善德的官吏被误打误撞圣上要求将岭南的新鲜荔枝运到长安的故事。迫于压力，他背负着全家的安危，在没有朝廷帮助的情况下通过各种的手段，最终将第一批的做实验的荔枝送了出去。在送荔枝的骑手离开后，李善德呆立在道路上，一动不动，内心感到无比的恐惧。因为他这辈子，从来没花过这么多钱在一件毫无胜算的事情上。 我觉得学习竞赛也是这样的。 竞赛在每周的周二、周四、周五的下午，每天的晚自习和周六的大半天上课。我粗略的计算了以下，我们一周会花费大约 333333 个小时也就是 118800118800118800 秒，这足够让安老师讲 202020 个精神明亮的人了。 如果其他的人都把这段时间用来学习，那么 111 年别人就比你多上了 160016001600 节文化课，可是真正拿到强基计划降分录取资格的人却屈指可数。 竞赛的同学们以一年少上 160016001600 节文化课为代价为了那渺茫的目标而前进，这跟李善德将荔枝送往长安这样的毫无胜算的事情不是一样的吗？ 正如小说中他的朋友所说“没有胜算的事，你干嘛还干？” 可是，每一届都人坚持到最后。或许他们并不是只为了进入清华北大学习，而是因为他们有一种高贵的不可一世的精神。作为回应，马伯庸在书中写到： 就算失败，我也想知道，自己倒在距离终点多远的地方。 竞赛以残酷的现实展现了无数的竞赛生的勇气美，让他们鼓舞着无数奋斗着的人。每一个竞赛生拼搏一次，天上飘落一粒沙，于是形成了撒哈拉。每一个竞赛人拼搏一次，天空飘落一片雪，至此雪花拥抱撒哈拉。就让这雪花拥抱的撒哈拉裹挟着无数竞赛人的泪与汗，一同成为竞赛路上勇气与坚强之美的结晶吧！ 结束 我不知道你是否曾在暴雨倾盆之时站在窗边，看雨滴落下。每一滴雨裹挟着力量从天空中奋力俯冲而下。有的冲进了池塘溅起一池涟漪，有的落在了树枝上击落了一树枯叶。但是也有一些雨滴落在了窗户上，缓缓的滑下。留下的唯一一丝痕迹也稍纵即逝，消失在了大雨之中。 或许，你不论怎样努力都只是人们茶余饭后的谈资吧。正如杨慎在诗中说的，&quot;古今多少事，都付笑谈中&quot;。但是 我坚信，奋斗的人从来不会为自己的无能或是路途的阻碍而叹息。因为在前进的路途中路边的积水中会闪烁着你的倒影，你将放着耀眼的光线砥砺前行。 ","link":"https://doittomorrow.xyz/post/jing-sai-zhi-mei/"},{"title":"[ABC345D] Tiling 的题解","content":"题目大意 有一个由 HHH 行和 WWW 列组成的网格，每个单元格的边长为 111 ，我们有 NNN 块瓷砖。第 iii 个图块 (1≤i≤N1\\le i\\le N1≤i≤N) 是一个大小为 Ai×BiA_i\\times B_iAi​×Bi​ 的矩形。请判断是否有可能将这些图块放置在网格中，从而满足以下所有条件： 每个单元格都正好被一个图块覆盖。 有未使用的瓦片也没关系。 瓦片在放置时可以旋转或翻转。但是，每块瓦片必须与单元格的边缘对齐，不得超出网格。 其中 1≤N≤7,1≤H,W≤10,1≤Ai,Bi≤101\\le N\\le 7,1 \\le H,W \\le 10,1\\leq A_i,B_i\\leq 101≤N≤7,1≤H,W≤10,1≤Ai​,Bi​≤10。 思路 显而易见的这个题目是一个 dfs 搜索题，毕竟 H,WH,WH,W 只有可怜的 101010。 对于每一块，可以选或者不选。如果不选择，那么就直接对下一块进行递归搜索。 如果选择，那么枚举这一块的方向和左上角的位置，判断这些区域是否没有被覆盖。 如果是空的，那么就将这里覆盖并且递归下一块。 但是不可避免的，这道题目还需要进行剪枝才可以通过。 剪枝 111 对于瓷砖排列的顺序，显然按面积从大到小排序是最优的。 因为在搜索时现将较大的放入后可以放置的区域就变少了，那么如果放置较小的瓷砖时就回更快的发现无解。 剪枝 222 在搜索的过程中，我们可以记录下一共覆盖的地板的数量。 如果将剩下来所有的瓷砖全部的体积加起来还是不能将他们放满的话，那么就直接返回。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; void io(){ios::sync_with_stdio(false);cin.tie(nullptr);} template&lt;typename T&gt;void write(T x){if(x&lt;0) cout&lt;&lt;'-', x=-x;if(x&gt;9) write(x/10);cout&lt;&lt;(char)(x%10+48);} const int N=20; int num,n,m,s[N]; struct node{int x,y;}a[N]; bool cmp(node a,node b){return a.x*a.y&gt;b.x*b.y;} bool vis[N][N]; bool ck(){ //判断是否全部覆盖 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(!vis[i][j]) return 0; return 1; } bool emp(int x,int xx,int y,int yy){ //判断从是否为空的 for(int i=x;i&lt;xx;i++) for(int j=y;j&lt;yy;j++) if(vis[i][j]) return 0; return 1; } void fill(int x,int xx,int y,int yy,bool val){ //将这个区域覆盖 for(int i=x;i&lt;xx;i++) for(int j=y;j&lt;yy;j++) vis[i][j]=val; } void dfs(int k,int sum){ if(ck()) cout&lt;&lt;&quot;Yes\\n&quot;,exit(0); if(k==num+1) return; if(sum+s[k]&lt;n*m) return; //剪枝 2 dfs(k+1,sum); for(int i=1;i+a[k].x&lt;=n+1;i++){ //竖着 for(int j=1;j+a[k].y&lt;=m+1;j++){ if(emp(i,i+a[k].x,j,j+a[k].y)){ fill(i,i+a[k].x,j,j+a[k].y,1); dfs(k+1,sum+a[k].x*a[k].y); fill(i,i+a[k].x,j,j+a[k].y,0); } } } for(int i=1;i+a[k].y&lt;=n+1;i++){ //横着 for(int j=1;j+a[k].x&lt;=m+1;j++){ if(emp(i,i+a[k].y,j,j+a[k].x)){ fill(i,i+a[k].y,j,j+a[k].x,1); dfs(k+1,sum+a[k].x*a[k].y); fill(i,i+a[k].y,j,j+a[k].x,0); } } } } void solve(){ cin&gt;&gt;num&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=num;i++) cin&gt;&gt;a[i].x&gt;&gt;a[i].y; sort(a+1,a+1+num,cmp); //剪枝 1 for(int i=num;i&gt;=1;i--) s[i]=s[i+1]+a[i].x*a[i].y; dfs(1,0); cout&lt;&lt;&quot;No\\n&quot;; } signed main(){io(); int T=1; while(T--){ solve(); } return 0; } ","link":"https://doittomorrow.xyz/post/abc345d-tiling-de-ti-jie/"},{"title":"[CF1941D] Rudolf and the Ball Game 的题解","content":"题目大意 有 nnn 个人投球，投了 mmm 次。第 iii 次投球时想左、右或者随便一个方向投掷 rir_iri​ 个人。从第 xxx 个人开始投球，询问最后球在最后有可能在谁的手里。 其中 1≤n,m≤1000,1≤x,r≤n,∑n⋅m≤2×1051\\le n,m \\le 1000,1\\le x,r\\le n,\\sum n\\cdot m \\le 2\\times 10^51≤n,m≤1000,1≤x,r≤n,∑n⋅m≤2×105。 思路 如果遇到方向不确定的情况，可以暴力的考虑直接枚举。考虑在最坏的情况下，全部的投球肯能方向不确定，那么我们就需要枚举 2m2^m2m，因为这些人一共会接到 2m2^m2m 次球。 在一轮投球中只有 nnn 个人但是却接到了 2m2^m2m 次球，可见一个人可能会多次接到球。因为在一轮中，不论一个人接到多少次球那么效果其实都是一样的。 所以设 fi,jf_{i,j}fi,j​ 表示在第 iii 次投球时，第 jjj 个人是否有可能拿到球。假设 g(j,ri)g(j,r_i)g(j,ri​) 表示第 jjj 个人移动 rir_iri​ 后的位置，发么状态转移方程为 fi,g(j,ri)=max⁡(fi,g(j,ri),fi−1,j)f_{i,g(j,r_i)}=\\max(f_{i,g(j,r_i)},f_{i-1,j}) fi,g(j,ri​)​=max(fi,g(j,ri​)​,fi−1,j​) AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=1005; int n,m,a[N],f[N][N],x; char c[N]; void solve(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;x; for(int i=1;i&lt;=m;i++) cin&gt;&gt;a[i]&gt;&gt;c[i]; for(int i=0;i&lt;=m;i++) for(int j=0;j&lt;=n;j++) f[i][j]=0; f[0][x-1]=1; for(int i=1;i&lt;=m;i++){ for(int j=0;j&lt;n;j++){ if(c[i]=='0'||c[i]=='?') f[i][(j+a[i])%n]|=f[i-1][j]; if(c[i]=='1'||c[i]=='?') f[i][(j-a[i]+n)%n]|=f[i-1][j]; } } vector&lt;int&gt; ans; for(int i=0;i&lt;n;i++) if(f[m][i]) ans.push_back(i+1); cout&lt;&lt;ans.size()&lt;&lt;'\\n'; for(int i:ans) cout&lt;&lt;i&lt;&lt;' '; cout&lt;&lt;'\\n'; }signed main(){ ios::sync_with_stdio(false); cin.tie(0); int T;cin&gt;&gt;T; while(T--) solve(); return 0; } ","link":"https://doittomorrow.xyz/post/cf1941d-rudolf-and-the-ball-game-de-ti-jie/"},{"title":"[CF1941E] Rudolf and k Bridges 的题解","content":"题目大意 在第 (i,j)(i,j)(i,j) 个格子修建一个桥墩需要 ai,j+1a_{i,j}+1ai,j​+1 的花费而且要求 (i,0)(i,0)(i,0) 与 (i,m)(i,m)(i,m) 必须修建桥墩并且桥墩之间的距离不得大于 ddd。现在需要求见 kkk 个连续的桥，求最小代价。 其中 1≤k≤n≤100,3≤m≤2⋅10,1≤d≤m1\\le k\\le n \\le 100,3\\le m\\le 2\\cdot 10,1\\le d\\le m1≤k≤n≤100,3≤m≤2⋅10,1≤d≤m。 思路 因为每一座桥修建的代价与其他桥是否修建无关，所以我们可以将每一座桥的修建代价求解出来，最终求出连续 kkk 座桥全部修建的最小值。 假设 fif_ifi​ 表示在第 iii 个位置修建桥墩而且 111 至 i−1i-1i−1 在修建则桥墩之后全部可以修桥的最小花费。 因为在第 iii 个位置修建桥墩前，从 i−d−1i-d-1i−d−1 到 i−1i-1i−1 只要有一个修建桥墩就可以，所以状态转移方程如下： fi=min⁡j=i−d−1i−1fjf_i= \\min_{j=i-d-1}^{i-1} f_j fi​=j=i−d−1mini−1​fj​ 这样写的时间复杂度为 O(T⋅nmd)O(T\\cdot nmd)O(T⋅nmd) 无法通过此题，可以考虑使用单点修改区间最小值查询线段树进行维护，这样时间复杂度就变成了 O(T⋅nmlog⁡d)O(T\\cdot nm \\log d)O(T⋅nmlogd)。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=2e5+5,INF=0x3f3f3f3f3f3f3f3f; int n,m,num,d,a[N],f[N],s[N&lt;&lt;2],ans[N]; void change(int k,int l,int r,int x,int v) { if(l==r&amp;&amp;l==x) { s[k]=v; return; } if(x&lt;l||x&gt;r) return; int mid=(l+r)/2; if(l&lt;=x&amp;&amp;x&lt;=mid) change(k*2,l,mid,x,v); if(mid+1&lt;=x&amp;&amp;x&lt;=r) change(k*2+1,mid+1,r,x,v); s[k]=min(s[k*2],s[k*2+1]); } int ask(int k,int l,int r,int x,int y) { if(y&lt;l||x&gt;r) return INF; if(x&lt;=l&amp;&amp;r&lt;=y) return s[k]; int mid=(l+r)/2; return min(ask(k*2,l,mid,x,y),ask(k*2+1,mid+1,r,x,y)); } void go(int number){ for(int i=1;i&lt;=m;i++) cin&gt;&gt;a[i]; f[1]=1; change(1,1,m,1,1); for(int i=2;i&lt;=m;i++){ f[i]=ask(1,1,m,max(i-d-1,1ll),max(i-1,1ll))+a[i]+1; change(1,1,m,i,f[i]); } ans[number]=f[m]; } void solve(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;num&gt;&gt;d; for(int i=1;i&lt;=n;i++) go(i); for(int i=1;i&lt;=n;i++) ans[i]+=ans[i-1]; int sum=INF; for(int i=1;i+num-1&lt;=n;i++) sum=min(sum,ans[i+num-1]-ans[i-1]); cout&lt;&lt;sum&lt;&lt;'\\n'; }signed main(){ ios::sync_with_stdio(false); cin.tie(0); int T;cin&gt;&gt;T; while(T--) solve(); return 0; } ","link":"https://doittomorrow.xyz/post/cf1941e-rudolf-and-k-bridges-de-ti-jie/"},{"title":"[CF1878F] Vasilije Loves Number Theory 的题解","content":"题目大意 令 d(x)d(x)d(x) 表示 xxx 的正因子数量，给定 n,qn,qn,q。现有两种操作： 给定 xxx，令 n←n⋅xn\\gets n\\cdot xn←n⋅x。同时询问是否存在一个正整数 aaa 满足 gcd⁡(a,n)=1\\gcd(a,n)=1gcd(a,n)=1 且 d(n⋅a)=nd(n\\cdot a)=nd(n⋅a)=n。 将 nnn 还原为最初的值。 数据保证任何时刻，d(n)≤109d(n)\\leq 10^9d(n)≤109。 思路 因为题目其实并没有要求输出 aaa 具体的值，所以我们并不需要真正的将 aaa 求解出来，而只需要判断存在性就可以了。 因为 nnn 可能会很多次被乘以 xxx，所以我们就可以储存 nnn 的所有的质因子。 假设 nnn 在质因数分解之后有 kkk 个质因子，而且第 iii 个质因子出现了 xix_ixi​ 次，那么总共的因子数量就是 ∏i=1kxi+1\\prod_{i=1}^{k} x_i+1∏i=1k​xi​+1。 对于这个性质，我们可以感性的理解一下：对于每一个质因子，我们可以选 num∈[0,xi]num\\in[0,x_i]num∈[0,xi​] 个，即有 xi+1x_i+1xi​+1 种可能性。通过乘法原理就可以得到因子数量为 ∏i=1kxi+1\\prod_{i=1}^{k} x_i+1∏i=1k​xi​+1。 如果满足 d(n)∣nd(n)|nd(n)∣n 就一定可以找到满足条件的 aaa 反之就不可能，理由如下： 对于 aaa 取任何数一定满足 d(a⋅n)∣d(n)d(a\\cdot n)|d(n)d(a⋅n)∣d(n)。 因为 d(n)=∏i=1kxi+1d(n)=\\prod_{i=1}^{k} x_i+1d(n)=∏i=1k​xi​+1，d(a⋅n)=∏i=1kxi+yi+1d(a\\cdot n)=\\prod_{i=1}^{k} x_i+y_i+1d(a⋅n)=∏i=1k​xi​+yi​+1，其中 yiy_iyi​ 以 iii 为 aaa 的质因子的个数。 对于 d(a⋅n)d(a\\cdot n)d(a⋅n) 一定可以找到一个 aaa 使 d(n)⋅q=d(n)d(n)\\cdot q=d(n)d(n)⋅q=d(n)，此时的 a=sq−1a=s^{q-1}a=sq−1，其中 sss 是一个极大质数。 因为题目要求 gcd⁡(a,n)=1\\gcd(a,n)=1gcd(a,n)=1，所以只要满足 sss 并非 nnn 的质因子即可。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; int n,q; map&lt;int,int&gt; mp,mp1; void solve() { cin&gt;&gt;n&gt;&gt;q; for(int i=2;i*i&lt;=n;i++) { while(n%i==0){ mp[i]++; n/=i; } } if(n&gt;1){ mp[n]++; } mp1=mp; for (int i=1,op,x;i&lt;=q;i++){ std::cin&gt;&gt;op; if(op==2){ mp=mp1; continue; } cin&gt;&gt;x; for(int j=2;j*j&lt;=x;j++) while(x%j==0) mp[j]++,x/=j; if(x&gt;1) mp[x]++; int cnt=1; for(auto i:mp) cnt*=(i.second+1); bool flag=1; for(int j=2;j*j&lt;=cnt;j++){ int sum=0; while(cnt%j==0) sum++,cnt/=j; if(sum&gt;mp[j]){ flag=0; break; } } if(cnt&gt;1&amp;&amp;!mp[cnt]||!flag) cout&lt;&lt;&quot;NO\\n&quot;; else cout&lt;&lt;&quot;YES\\n&quot;; } mp.clear(); cout&lt;&lt;'\\n'; } signed main() { ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin&gt;&gt;t; while(t--) solve(); return 0; } ","link":"https://doittomorrow.xyz/post/cf1878f-vasilije-loves-number-theory-de-ti-jie/"},{"title":"[CF1658D1] 388535 (Easy Version) 的题解","content":"题目大意 给定 l,rl,rl,r 和一个长为 r−l+1r−l+1r−l+1 的所有数都不相等的序列 aaa。请你找到任意一个数 xxx 满足序列 aaa 中的所有数异或上 xxx 后正好为 [l,l+1,⋯ ,r−1,r][l,l+1,\\cdots,r−1,r][l,l+1,⋯,r−1,r] 的一个排列。 ttt 组数据，1⩽t⩽1051\\leqslant t\\leqslant 10^51⩽t⩽105。 0=l⩽r,ai&lt;217\\color{red}{0=l}\\color{black}\\leqslant r,a_i&lt;2^{17}0=l⩽r,ai​&lt;217。 ∑(r−l+1)⩽217\\sum(r-l+1)\\leqslant 2^{17}∑(r−l+1)⩽217。 思路 因为 xxx 的二进制为的取值并不会互相影响，所以我们可以将 xxx 和 aaa 数组内的二进制位分离出来讨论。 因为异或操作可以将二进制为取反或者保持不变，所以我们可以统计出每一个二进制位的 111 的数量。 如果 aaa 数组内某一位为 111 的数量的和与排列的数组内这一位为 111 的数量，那么 ansansans 这一位就应该是 111 反之就是 000。 AC Code #include&lt;bits/stdc++.h&gt; using namespace std; void io(){ios::sync_with_stdio(false);cin.tie(nullptr);} const int N=2e5+5; int l,r,s[30][2]; void solve(){ cin&gt;&gt;l&gt;&gt;r; for(int i=l,x,y;i&lt;=r;i++){ cin&gt;&gt;x,y=i; for(int j=1;j&lt;=20;j++){ s[j][x&amp;1]++; s[j][y&amp;1]--; x&gt;&gt;=1,y&gt;&gt;=1; } } int ans=0; for(int i=20;i&gt;=1;i--){ ans=ans&lt;&lt;1|(s[i][1]!=0); s[i][1]=0; } cout&lt;&lt;ans&lt;&lt;'\\n'; } signed main(){io(); int T=1; cin&gt;&gt;T; while(T--){ solve(); } return 0; } ","link":"https://doittomorrow.xyz/post/cf1658d1-388535-easy-version-de-ti-jie/"},{"title":"[CF1511D] Min Cost String 的题解","content":"题目大意 现在需要使用从小写字母 aaa 开始的 kkk 种字符，构造一个长度为 nnn 的字符串 sss，使满足 i,j∈[1,n−1]，i≠ji,j\\in[1,n-1]，i\\neq ji,j∈[1,n−1]，i​=j 且 ai=aj,ai+1=aj+1a_i=a_j,a_{i+1}=a_{j+1}ai​=aj​,ai+1​=aj+1​ 的数对的数量最少。 其中 1≤n≤2×105,1≤k≤261\\le n \\le 2\\times 10^5,1\\le k \\le 261≤n≤2×105,1≤k≤26。 思路 在使用 kkk 总字符的情况下，可以构造长度为 222 的字符串的种类为 A⁡k2\\operatorname{A}^2_kAk2​。 但是因为在构造时上一队的字符会和这一对的字符组成以前出现过的字符。 为了避免这个情况，我们可以规定每一对里两个字母 sis_isi​ 和 si+1s_{i+1}si+1​ 满足 si&lt;si+1s_i &lt; s_{i+1}si​&lt;si+1​，所以当与上一组组合时就一定会满足 si−1&gt;sis_{i-1}&gt;s_isi−1​&gt;si​ 自然就不会出现重复的情况。 因为在如果所有的 sis_isi​ 都小于 si+1s_{i+1}si+1​ 时，我们就会漏掉一种 si=si+1s_i=s_{i+1}si​=si+1​ 的情况，所以就需要特别的在每一个 si+1=si+1s_i+1=s_{i+1}si​+1=si+1​ 的前面添加一个 sis_isi​。 因为 ∑i=1k2×(k−i)+1\\sum_{i=1}^k 2\\times(k-i) +1∑i=1k​2×(k−i)+1 =∑i=1k2×k−2×i+1=\\sum_{i=1}^k 2\\times k-2\\times i+1=∑i=1k​2×k−2×i+1 =2×k2−2×k×(1+k)2+k= 2\\times k^2-2\\times \\frac{k\\times (1+k)}{2}+k=2×k2−2×2k×(1+k)​+k =2×k2−k−k2+k=2\\times k^2 -k-k^2+k=2×k2−k−k2+k =k2=k^2=k2 所以，使用以上方法构造的没有重复的序列最长为 k2k^2k2。 假设第 iii 组字符串出现的次数为 cnticnt_icnti​，那么一定满足 ∑i=1k2cnti\\sum_{i=1}^{k^2} cnt_i∑i=1k2​cnti​ 是一定的。 代价为 cost=∑i=1kcnti22−n−12cost=\\sum _{i=1}^k \\frac{cnt_i^2}{2}-\\frac{n-1}{2} cost=i=1∑k​2cnti2​​−2n−1​ 要使 costcostcost 最小，那么所有的 cnticnt_icnti​ 应该越相近越小，所以在 n&gt;k2n&gt;k^2n&gt;k2 的时候就应该将原来长度为 k2k^2k2 的字符串在后面进行重复。 直接模拟上面的操作，时间复杂度为 O(m)O(m)O(m)。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=2e5+5; int n,m,cnt,a[30][30]; void solve(){ cin&gt;&gt;n&gt;&gt;m; while(cnt&lt;n){ for(int i=0;i&lt;m;i++){ if(cnt&gt;=n) break; putchar('a'+i); cnt++; for(int j=i+1;j&lt;m;j++){ if(cnt&gt;=n) break; putchar('a'+i); cnt++; if(cnt&gt;=n) break; putchar('a'+j); cnt++; if(cnt&gt;=n) break; } } } } signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); int T=1; while(T--) solve(); return 0; } ","link":"https://doittomorrow.xyz/post/cf1511d-min-cost-string-de-ti-jie/"},{"title":"[CF749C] Voting","content":"题目大意 给定一个字符串，字符串中字符为 D\\texttt{D}D 或 R\\texttt{R}R，代表两个团队。从 111 开始，每个人都有发言的权利，发言时，可以禁言一个人，使那个人以后都不能发言。 如果一圈发言完还有1个以上的人能发言，就从 111 重新开始，直到只有 111 个人能发言，那个人所在的团队获胜。 思路 当一个人发言时，他应该将另外一队在他后面发言中最靠近他的人禁言。 因为一旦另外一队的人被禁言了一个，那么我们这一队可以发言的人就多了一个。如果禁言的人离正在发言的人很远，那么在紧挨着他的那个人就有机会将正在发言的人那一队的人禁言。而如果将距自己最近的人禁言了，那么自己之后的队友就可以发言并发将将后面的对方的人禁言的了。 因为在发言时就模拟将对方禁言过于复杂，我们其实可以直接记录双方禁言对方的数量。 如果对方禁言己方的数量大于 000 就说明自己被禁言了，将对方禁言的数量减 111，将自己标记为被禁言。反之说明对方并未将你禁言，将己方禁言对方的数量加 111。 AC Code #include&lt;bits/stdc++.h&gt; using namespace std; const int N=2e5+5; int n,s1,s2,cnt; bool vis[N]; char a[N]; signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n&gt;&gt;a+1; while(cnt&lt;=n){ for(int i=1;i&lt;=n;i++){ if(vis[i]) continue; if(a[i]=='D'){ if(s2&gt;0) s2--,vis[i]=1; else s1++,cnt++; } else{ if(s1&gt;0) vis[i]=1,s1--; else s2++,cnt++; } } } if(s1&gt;s2) cout&lt;&lt;'D'; else cout&lt;&lt;'R'; return 0; } ","link":"https://doittomorrow.xyz/post/cf749c-voting/"},{"title":"[ABC243C] Collision 2 的题解","content":"题目大意 给你 n(2≤n≤2×105)n(2\\le n\\le 2\\times 10^5)n(2≤n≤2×105) 个，第 iii 个点在第 xix_ixi​ 行从 yiy_iyi​ 开始向 sis_isi​ 一直移动，判断是否会有点在运动时与其他点重合。 思路 因为每一个点只会在 yiy_iyi​ 行移动，所以每一行都是单独的，可以分开讨论。 将 yiy_iyi​ 行的所有的 xix_ixi​ 与 sis_isi​ 放到一个数组里，接着将他们按照 xix_ixi​ 排序。 对于每一行，一次遍历所有的元素，如果比遍历到一个 xix_ixi​ 的 sis_isi​ 是 R\\texttt{R}R 那么记录下来。 接下来如果看到 sis_isi​ 是 L\\texttt{L}L 那么就输出 Yes\\texttt{Yes}Yes 并结束程序。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long #define x first #define y second using namespace std; const int N=2e5+5; int n,y[N],x[N]; map&lt;int,vector&lt;pair&lt;int,char&gt; &gt; &gt;a; //将一个整数映射到一个长度可变的类型是 int 和 char 的数组 map&lt;int,bool&gt; vis; //将一个 int 映射到 bool 变量 signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); //关闭输入输出流，但是就只能用 cin 与 cout cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;x[i]&gt;&gt;y[i]; } for(int i=1;i&lt;=n;i++){ char ch; cin&gt;&gt;ch; a[y[i]].push_back({x[i],ch}); } for(int i=1;i&lt;=n;i++){ if(vis.count(y[i])){ //处理过这一行了 continue; } vis[y[i]]=1; sort(a[y[i]].begin(),a[y[i]].end()); //将这个数组按照从小到大排序 bool flag=0; for(auto v:a[y[i]]){ if(v.y=='R'){ flag=1; } else{ if(flag){ cout&lt;&lt;&quot;Yes\\n&quot;; return 0; } } } } cout&lt;&lt;&quot;No\\n&quot;; return 0; } ","link":"https://doittomorrow.xyz/post/abc243c-collision-2-de-ti-jie/"},{"title":"[AGC018B] Sports Festival","content":"题目大意 有 nnn 个人 mmm 个活动，告诉你每一个人对于活动喜欢程度的排序，你可以鸽掉一些活动。如果一个最喜欢的活动被鸽了，那么他就会参加次喜欢的，依次类推直到参加为止。 求参加人数最多的那个项目，参加人数最少是多少。 思路 做法： 首先模拟出每一个活动的参加人数，依次将人数最多的活动鸽掉，一遍鸽一遍统计最小值。 理由： 假设你已经鸽掉了一些活动，你么现在总能找到一个参加人数最多的项目，假设这个项目是第 xxx 个项目。如果将非 xxx 的项目鸽掉，那么参加第 xxx 个项目的人就并不会减少反而还会增加，这对将整体的最大值减小是没有任何效果的。 假设你鸽掉了第 xxx 个项目，那么你肯定就又可以找到一个参加人数是最多的项目，假设是第 yyy 个项目。那么如果不鸽掉第 yyy 个项目与前面鸽掉第 xxx 个项目的效果其实是一样的。所以在这次操作就只能将 yyy 鸽掉，否则就没有意义。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=305; int n,m,a[N][N],s[N],top[N],ans=1e18; signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ cin&gt;&gt;a[i][j]; top[i]=1; } } for(int i=1;i&lt;=n;i++){ s[a[i][1]]++; } for(int i=1,p,mmax;i&lt;=m;i++){ mmax=0; for(int j=1;j&lt;=m;j++){ if(s[j]&gt;mmax){ mmax=s[j]; p=j; } } ans=min(ans,mmax); s[p]=-1; for(int j=1;j&lt;=n;j++){ bool flag=0; while(s[a[j][top[j]]]==-1){ top[j]++; flag=1; } if(flag){ s[a[j][top[j]]]++; } } } cout&lt;&lt;ans&lt;&lt;'\\n'; return 0; } ","link":"https://doittomorrow.xyz/post/agc018b-sports-festival/"},{"title":"[CF226B] Naughty Stone Piles 题解","content":"题目大意 就是普通的石子合并，但是添加了限制条件：每一堆石子合并的次数不能超过 kkk 次。 思路 对于普通的石子合并，将除了最大的石子外的所有的石子全部合并到最大的石子上肯定是最优的。 证明： 假设石子的重量为 a1,a2,a3,⋯ ,an+1,ana_1,a_2,a_3,\\cdots ,a_{n+1},a_na1​,a2​,a3​,⋯,an+1​,an​，且满足对于 i∈[1,n−1]i\\in [1,n-1]i∈[1,n−1]，ai≤ai+1a_i\\le a_{i+1}ai​≤ai+1​。假设我们要将 x,y,zx,y,zx,y,z 三堆石子合并，那么有以下几种可能出现合并的代价： ax+aya_x+a_yax​+ay​，代表将 xxx 和 yyy 依次合并到 zzz。 ax+aza_x+a_zax​+az​，代表将 xxx 和 zzz 依次合并到 yyy。 ay+aza_y+a_zay​+az​，代表将 yyy 和 zzz 依次合并到 zzz。 因为 ax≤ay≤aza_x\\le a_y\\le a_zax​≤ay​≤az​，所以 ax+ay≤ax+az,ay+aza_x+a_y\\le a_x+a_z,a_y+a_zax​+ay​≤ax​+az​,ay​+az​。可见，在全部依次合并的情况下将除了最大的石子外的所有的石子全部合并到最大的石子上肯定是最优的。 对于现将一堆石子合并到另外一堆再进行合并肯定是更劣的，因为同样的两项的和依然会存在，而且因为一堆被合并了两次，所以还还要多重复一次。 我们可以将这个情况抽象成为一棵树： 将 xxx 合并到 yyy 就相于从 xxx 到 yyy 连一条边，这张图的代价为每个点的点权乘以这个点的度 −1-1−1（即合并次数）的和。因为题目有限制每一堆石子合并的次数不能超过 kkk 次，所以这个题目求的就是每个节点至多有 kkk 个孩子的树的代价的最小值。显然，我们可以将 aaa 数组排序，贪心的从小到大尽可能将每一层都放满。 对于样例首先将输入排序得到 4,3,2,1,14,3,2,1,14,3,2,1,1。 对于 k=3k=3k=3 时，我们得到了这样的一棵树： 其代价为 4×0+2×1+3×1+1×2+1×3=94\\times 0+2\\times 1+3\\times 1+1\\times 2+1\\times 3=94×0+2×1+3×1+1×2+1×3=9。 通过观察可以得到第 iii 层有 ki−1k^{i-1}ki−1 个节点，所以在实际的计算中我们并不需要真正将树建出来，而是直接统计就可以了。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=1e5+5; int n,a[N],m,k; map&lt;int,int&gt; mp; bool cmp(int a,int b){ return a&gt;b; } int ksm(int a,int b){ int ans=1; while(b){ if(b&amp;1){ ans=ans*a; } b&gt;&gt;=1; a=a*a; } return ans; } signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i]; } sort(a+1,a+1+n,cmp); for(int i=1;i&lt;=n;i++){ a[i]+=a[i-1]; } cin&gt;&gt;m; while(m--){ int ans=0; cin&gt;&gt;k; if(mp[k]){ cout&lt;&lt;mp[k]&lt;&lt;' '; continue; } int i=1,cnt; for(i=1,cnt=0;i&lt;=n;i+=ksm(k,cnt+1),cnt++){ ans+=(a[i]-a[i-ksm(k,cnt)])*cnt; } i-=ksm(k,cnt); ans+=(a[n]-a[i])*(cnt); mp[k]=ans; cout&lt;&lt;ans&lt;&lt;' '; } return 0; } ","link":"https://doittomorrow.xyz/post/cf226b-naughty-stone-piles-ti-jie/"},{"title":"[ARC115B] Plus Matrix 的题解","content":"题目大意 给你一个 n×nn\\times nn×n 的数组 CCC，ci,j=ai+bjc_{i,j}=a_i+b_jci,j​=ai​+bj​，求 aaa 数组与 bbb 数组，不保证有解，其中 1≤n≤500,1≤ci,j≤1091\\le n\\le 500,1\\le c_{i,j}\\le 10^91≤n≤500,1≤ci,j​≤109，而且 ai,bia_i,b_iai​,bi​ 都是非负整数。 [a1+b1a1+b2⋯a1+bn−1a1+bna2+b1a2+b2⋯a2+bn−1a2+bn⋮⋮⋮⋮⋮an−1+b1an−1+b2⋯an−1+bn−1an−1+bnan+b1an+b2⋯an+bn−1an+bn]\\begin{bmatrix} a_1+b_1&amp;a_1+b_2&amp;\\cdots&amp;a_1+b_{n-1}&amp;a_1+b_n\\\\ a_2+b_1&amp;a_2+b_2&amp;\\cdots&amp;a_2+b_{n-1}&amp;a_2+b_n\\\\ \\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots\\\\ a_{n-1}+b_1&amp;a_{n-1}+b_2&amp;\\cdots&amp;a_{n-1}+b_{n-1}&amp;a_{n-1}+b_n\\\\ a_n+b_1&amp;a_n+b_2&amp;\\cdots&amp;a_n+b_{n-1}&amp;a_n+b_n\\\\ \\end{bmatrix}⎣⎢⎢⎢⎢⎢⎡​a1​+b1​a2​+b1​⋮an−1​+b1​an​+b1​​a1​+b2​a2​+b2​⋮an−1​+b2​an​+b2​​⋯⋯⋮⋯⋯​a1​+bn−1​a2​+bn−1​⋮an−1​+bn−1​an​+bn−1​​a1​+bn​a2​+bn​⋮an−1​+bn​an​+bn​​⎦⎥⎥⎥⎥⎥⎤​ 思路 因为 ci,j=ai+bj,ci,j+1=ai+bj+1c_{i,j}=a_i+b_j,c_{i,j+1}=a_i+b_{j+1}ci,j​=ai​+bj​,ci,j+1​=ai​+bj+1​。 所以 ci,j−ci,j+1=ai+bj−(ai+bj+1)=aj−aj+1c_{i,j}-c_{i,j+1}=a_i+b_j-(a_i+b_{j+1})=a_j-a_{j+1}ci,j​−ci,j+1​=ai​+bj​−(ai​+bj+1​)=aj​−aj+1​。 将我们一行依次相减，就得到了 bbb 的一组关系，其实就是 n−1n-1n−1 个等式。 {b1−b2=ci,1−ci,2⋯bn−1−bn=ci,n−1−ci,n\\begin{cases} b_1-b_2=c_{i,1}-c_{i,2}\\\\ \\cdots\\\\ b_{n-1}-b_{n}=c_{i,n-1}-c_{i,n} \\end{cases}⎩⎪⎨⎪⎧​b1​−b2​=ci,1​−ci,2​⋯bn−1​−bn​=ci,n−1​−ci,n​​ 显然，对于所有的 i∈[1,n]i\\in [1,n]i∈[1,n] 这 n−1n-1n−1 个等式应该都是满足的。如果不能满足这个条件，那么就是无解的。 因为 ai,bia_i,b_iai​,bi​ 都是非负整数，所以我们需要找到一组解使上面的等式全部满足。为了让答案在最后好处理，我们可以先找到一组最小解。 因为上面的方程对于所有的 i∈[1,n]i\\in [1,n]i∈[1,n] 都满足，所以我们只需要考虑一行就可以了，为了便于讨论，我选取了第 111 行。得到第 iii 行最小的元素 xxx，所有 bi=ai−xb_i=a_i-xbi​=ai​−x，对于 aaa 数组也是如此。 因为我们找到的是最小解，所有有可能会出现 ai+bj&lt;ci,ja_i+b_j&lt;c_{i,j}ai​+bj​&lt;ci,j​ 的情况。因为我们已经得到了 aaa 数组之间的关系，那么我们就可以将 aaa 数组全部加 111。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=505; int n,c[N][N],a[N],b[N]; signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=n;j++){ cin&gt;&gt;c[i][j]; } } for(int i=1;i&lt;n;i++){ for(int j=1;j&lt;n;j++){ if(c[i][j]-c[i][j+1]!=c[i+1][j]-c[i+1][j+1]){ cout&lt;&lt;&quot;No&quot;; return 0; } } } for(int j=1;j&lt;n;j++){ for(int i=1;i&lt;n;i++){ if(c[i][j]-c[i][j+1]!=c[i+1][j]-c[i+1][j+1]){ cout&lt;&lt;&quot;No&quot;; return 0; } } } int mmin=INT_MAX; for(int i=1;i&lt;=n;i++){ mmin=min(c[1][i],mmin); } for(int i=1;i&lt;=n;i++){ b[i]=c[1][i]-mmin; } mmin=INT_MAX; for(int i=1;i&lt;=n;i++){ mmin=min(c[i][1],mmin); } for(int i=1;i&lt;=n;i++){ a[i]=c[i][1]-mmin; } cout&lt;&lt;&quot;Yes\\n&quot;; int add=c[1][1]-a[1]-b[1]; for(int i=1;i&lt;=n;i++){ cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; } cout&lt;&lt;'\\n'; for(int i=1;i&lt;=n;i++){ cout&lt;&lt;b[i]+add&lt;&lt;&quot; &quot;; } return 0; } ","link":"https://doittomorrow.xyz/post/arc115b-plus-matrix-de-ti-jie/"},{"title":"Selling a Menagerie 的题解","content":"题面大意 动物园里有 nnn 个动物，第 iii 个动物害怕第 aia_iai​ 个动物，第 iii 个动物价值 cic_ici​ 元。现在我要将这些动物全部卖掉。显然，卖掉的动物编号可以构成一个排列 ppp。 考虑卖掉这些动物时： 若 aia_iai​ 在 iii 还没有卖掉之前就被卖掉了，现在卖掉 iii，可以获得 cic_ici​ 元； 若 aia_iai​ 在 iii 还没有卖掉之前没被卖掉，现在卖掉 iii，可以获得 2⋅ci2·c_i2⋅ci​ 元； 构造并输出赚钱最多的动物卖出顺序。 思路 显而易见，题目可以转化为图论进行解决。 将第 iii 个点向 aia_iai​ 连一条无向边，构成一个 nnn 个点 nnn 条边的基环树森林。 如果并没有其他的动物害怕第 iii 只动物，那么将第 iii 只动物卖出后并不会因为缺少了自己害怕的动物而减少价值。反映在图中即是将没有入度的点依次卖出，就是跑一次拓扑序。 因为这个图是一个基环树森林，所以在将所有的入度为 000 的点全部删除之后剩下的节点必然满足对于任意的 xxx 与 yyy 有且仅有一条边将他们链接。 我们可以贪心的考虑删除掉环中的那一个点。 假设节点 iii 害怕的动物为 aia_iai​，其价格为 cic_ici​，这个环内的节点为 sss，那么肯定有一个动物会因为自己害怕的动物已经卖出而变得便宜，不放假设变便宜的动物为 xxx。 这个环的价值就为 ∑i∈s(2×ci)−cx\\sum_{i\\in s}( 2\\times c_i)-c_x∑i∈s​(2×ci​)−cx​。因为 ∑i∈s(2×ci)\\sum_{i\\in s}( 2\\times c_i)∑i∈s​(2×ci​) 是一个定值，所以要使价值最大化就应该使 cxc_xcx​ 尽可能的小。如果提前卖掉的动物为为 mmm 那么 x=amx=a_mx=am​，所以提前删除的点 mmm 应该使 sams_{a_m}sam​​ 最小。 在每一次将环内的一个点卖出后，剩下的节点就可以通过拓扑序的方式依次删除。 注意，因为这是一个基环树森林，所以可能存在多个环。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=1e5+5; int n,du[N],s[N]; vector&lt;int&gt; v[N]; queue&lt;int&gt; qq; bool vis[N]; struct node{ int x,v; friend bool operator &lt; (const node a,const node b){ return a.v&gt;b.v; } }; priority_queue&lt;node&gt;q; void solve(){ cin&gt;&gt;n; int cnt=0; for(int i=1;i&lt;=n;i++){ v[i].clear(); du[i]=0; vis[i]=0; s[i]=0; } while(!q.empty()){ q.pop(); } for(int i=1,x;i&lt;=n;i++){ cin&gt;&gt;x; du[x]++; v[i].push_back(x); } for(int i=1;i&lt;=n;i++){ cin&gt;&gt;s[i]; } for(int i=1;i&lt;=n;i++){ if(du[i]==0){ qq.push(i); cnt++; vis[i]=1; cout&lt;&lt;i&lt;&lt;&quot; &quot;; } } while(!qq.empty()){ int x=qq.front(); qq.pop(); for(int i:v[x]){ du[i]--; if(du[i]==0){ cout&lt;&lt;i&lt;&lt;&quot; &quot;; qq.push(i); vis[i]=1; cnt++; } } } if(cnt==n){ return; } for(int i=1;i&lt;=n;i++){ if(vis[i]){ continue; } int p=0; while(vis[v[i][p]]) p++; q.push({v[i][p],s[i]}); } while(cnt&lt;n){ while(vis[q.top().x]) q.pop(); qq.push(q.top().x); cnt++; vis[q.top().x]=1; cout&lt;&lt;q.top().x&lt;&lt;&quot; &quot;; while(!qq.empty()){ int x=qq.front(); qq.pop(); for(int i:v[x]){ du[i]--; if(du[i]==0&amp;&amp;!vis[i]){ cout&lt;&lt;i&lt;&lt;&quot; &quot;; qq.push(i); cnt++; vis[i]=1; } } } }cout&lt;&lt;endl; } signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin&gt;&gt;t; while(t--){ solve(); } return 0; } ","link":"https://doittomorrow.xyz/post/selling-a-menagerie-de-ti-jie/"},{"title":"Unusual Minesweeper 题解","content":"题目大意 给你 nnn 个炸弹，第 iii 个炸弹在 (xi,yi)(x_i,y_i)(xi​,yi​) 的位置，可以将这一行与这一列的距离小于 kkk 的其他所有炸弹引爆，而且连锁的引爆不需要时间。每一秒你可以引爆一个炸弹，其中第 000 秒也可以引爆，并且第 iii 个炸弹在第 timeritimer_itimeri​ 的时候会自己爆炸。要求输出引爆所有炸弹的最小时间。 其中 1≤n≤2×105,0≤k≤109,−109≤x,y≤1091\\le n \\le 2\\times 10^5,0\\le k \\le 10^9,-10^9\\le x,y\\le 10^91≤n≤2×105,0≤k≤109,−109≤x,y≤109。 思路 因为炸弹爆炸的距离是一样的，所有对于任意的 xxx 可以引爆 yyy，那么在 yyy 被引爆时 xxx 也会被引爆。 对于这个性质，在输入时可以将所有可以相互引爆的炸弹先预处理出来作为一个集合，同时计算出每个集合自己爆炸所需要的时间，这个操作可以通过并查集进行处理。 对于任意的 x≤yx\\le yx≤y：如果时间为 xxx 时可以全部引爆，那么在 yyy 这一时刻也一定可以。如果时间为 yyy 时不可以全部引爆，那么在 xxx 时刻也绝对不可能将炸弹全部引爆。 根据这个规律，我们可以发现时间与全部引爆的关系是有单调性的，所以这个题目可以使用二分进行求解。 假设二分的时间为 midmidmid。如果这一组炸弹自己爆炸的时间 ≤mid\\le mid≤mid，那么在规定时间到达前就会自己爆炸，所以并不需要人为的引爆。反之，如果这一组爆炸的时间 &gt;mid&gt; mid&gt;mid，那么就需要将这一组进行人为的引爆。 因为在时间为 000 时也可以引爆炸弹，所以如果时间为 midmidmid，那么实际上是可以手动引爆 mid+1mid+1mid+1 组炸弹的。 二分的复杂度为 O(log⁡n)O(\\log n)O(logn)，checkcheckcheck 函数的复杂度为 O(n)O(n)O(n)，总时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=2e5+5; int n,m,fa[N],s[N],x[N],y[N]; struct node{ int x,y,id; }a[N]; bool vis[N]; bool cmp1(node a,node b){ if(a.x==b.x){ return a.y&lt;b.y; } return a.x&lt;b.x; } bool cmp2(node a,node b){ if(a.y==b.y){ return a.x&lt;b.x; } return a.y&lt;b.y; } int find_root(int x){ if(fa[x]==x){ return x; } return fa[x]=find_root(fa[x]); } bool ck(int mid){ memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=n;i++){ if(s[find_root(i)]&gt;mid){ vis[find_root(i)]=1; } } int sum=0; for(int i=1;i&lt;=n;i++){ sum+=vis[i]; } return sum&lt;=mid+1; } void solve(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i].x&gt;&gt;a[i].y&gt;&gt;s[i]; a[i].id=i; fa[i]=i; } sort(a+1,a+1+n,cmp1); a[0].x=a[0].y=-1e9-1; for(int i=1,p=0;i&lt;=n;i++){ if(a[i].x==a[i-1].x&amp;&amp;abs(a[i].y-a[i-1].y)&lt;=m){ int x=find_root(a[i].id),y=find_root(a[i-1].id); if(x!=y){ fa[y]=x; s[x]=min(s[x],s[y]); } } } sort(a+1,a+1+n,cmp2); for(int i=1,p=0;i&lt;=n;i++){ if(a[i].y==a[i-1].y&amp;&amp;abs(a[i].x-a[i-1].x)&lt;=m){ int x=find_root(a[i].id),y=find_root(a[i-1].id); if(x!=y){ fa[y]=x; s[x]=min(s[x],s[y]); } } } int l=0,r=n,ans=-1; while(l&lt;=r){ int mid=(l+r)/2; if(ck(mid)){ r=mid-1; ans=mid; } else{ l=mid+1; } } cout&lt;&lt;ans&lt;&lt;'\\n'; } signed main(){ ios::sync_with_stdio(false); cin.tie(nullptr); int T; cin&gt;&gt;T; while(T--){ solve(); }return 0; } ","link":"https://doittomorrow.xyz/post/unusual-minesweeper-ti-jie/"},{"title":"怎么优雅的踩爆 Treap","content":"在发布了文章 Treap 学习笔记后我认为我的平衡树能力已经登峰造极了。 但是 Treap 真 tmd 太难写了，所以我们的 czy 大佬开发除了一种可以优雅的踩爆 Treap 的绝佳方案。 #include&lt;bits/stdc++.h&gt; using namespace std; int n; struct tree{ vector&lt;int&gt; v; void add(int x){v.insert(lower_bound(v.begin(),v.end(),x),x);} void del(int x){v.erase(lower_bound(v.begin(),v.end(),x));} int getrnk(int x){return lower_bound(v.begin(),v.end(),x)-v.begin()+1;} int getval(int x){return v[x-1];} int getpre(int x){return *(--lower_bound(v.begin(),v.end(),x));} int getnxt(int x){return *upper_bound(v.begin(),v.end(),x);} }tr; int main(){ cin&gt;&gt;n; for(int i=1,op,x;i&lt;=n;i++){ cin&gt;&gt;op&gt;&gt;x; if(op==1) tr.add(x); if(op==2) tr.del(x); if(op==3) cout&lt;&lt;tr.getrnk(x)&lt;&lt;endl; if(op==4) cout&lt;&lt;tr.getval(x)&lt;&lt;endl; if(op==5) cout&lt;&lt;tr.getpre(x)&lt;&lt;endl; if(op==6) cout&lt;&lt;tr.getnxt(x)&lt;&lt;endl; } return 0; } ","link":"https://doittomorrow.xyz/post/zen-me-you-ya-de-cai-bao-treap/"},{"title":"[EGOI2021] Luna likes Love 的题解","content":"题目大意 有 2×n2\\times n2×n 个人站成一排，然后给每个人分配一个 111 至 nnn 之间的数字，每种数字出现 222 次。 现在，你可以进行两种操作： 删除操作，将数字相同且相邻的两人删除，删除后两端剩下的队列合并。 交换操作，交换相邻两个人的位置。 每次，问至少操作多少次能够删除所有人，操作包含删除操作和交换操作。 其中 1≤n≤5×105,1≤ai≤n1\\le n \\le 5\\times 10 ^5,1\\le a_i \\le n1≤n≤5×105,1≤ai​≤n。 思路 首先找到每种数字的位置。 如果第 iii 个数字在 xi,yix_i,y_ixi​,yi​。如果 xi,yix_i,y_ixi​,yi​ 相邻，那么可以直接删除，如果不相邻，统计使得相邻需 xi,yix_i,y_ixi​,yi​ 要的最少操作次数。 假设两组相同的元素的位置分别为 a1,a2a_1,a_2a1​,a2​ 与 b1,b2b_1,b_2b1​,b2​，且满足 a1&lt;b1&lt;b2&lt;a2,b1+1=b2a_1&lt;b_1&lt;b_2&lt;a_2,b_1+1=b_2a1​&lt;b1​&lt;b2​&lt;a2​,b1​+1=b2​。 假设先将 b1b_1b1​ 与 b2b_2b2​ 的数字消除在消除 a1a_1a1​ 与 a2a_2a2​ 位置的数字代价就是 a2−a1−1a_2-a_1-1a2​−a1​−1。但是如果先将 a1a_1a1​ 与 a2a_2a2​ 的数字消除在消除 b1b_1b1​ 与 b2b_2b2​ 位置的数字代价就是 a2−a1a_2-a_1a2​−a1​。 所以如果有相邻的元素，将他们优先删除掉显然优于将他们后来删掉。 如何统计区间中数字出现一次的数量，即找到 xj&lt;xix_j&lt;x_ixj​&lt;xi​ 且 yi&lt;yjy_i&lt;y_jyi​&lt;yj​，使用树状数组维护。 时间复杂度为 O(nlog⁡n)O(n\\log n)O(nlogn)。 AC Code #include&lt;bits/stdc++.h&gt; #define lowbit(x) (x&amp;-x) #define int long long using namespace std; const int N=1e6+5; int n,a[N],s[N],ans; struct node{int x,y;}x[N]; bool cmp(node a,node b){ return a.y-a.x&lt;b.y-b.x; } void updata(int x,int v){ for(int i=x;i&lt;N;i+=lowbit(i)) s[i]+=v; } int sum(int x){ int ans=0; for(int i=x;i&gt;=1;i-=lowbit(i)) ans+=s[i]; return ans; } signed main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n*2;i++){ cin&gt;&gt;a[i]; if(x[a[i]].x==0) x[a[i]].x=i; else x[a[i]].y=i; } sort(x+1,x+1+n,cmp); for(int i=1;i&lt;=n;i++){ ans+=x[i].y-x[i].x-1-sum(x[i].y)+sum(x[i].x); updata(x[i].y,1); updata(x[i].x,1); }cout&lt;&lt;ans+n&lt;&lt;endl; return 0; } ","link":"https://doittomorrow.xyz/post/egoi2021-luna-likes-love-de-ti-jie/"},{"title":"Snow Walking Robot 的题解","content":"题目大意 给你一个机器人和机器人的 nnn 个运动，要求你在给出的运动路径的基础上设计一种不会走重复的路径的方法，注意只能减少原来的步数而不能增加，其中 1≤n≤1051\\le n\\le 10^51≤n≤105。 思路 因为这道题目可以自由的配置路径并且要求机器人在最后回到原来的位置，那么就应该要到一种适合所有的移动步数的方法。 我们可以将所有的移动进行平移操作，把路径移动成下面这样。 这样，对于所有的移动，在知道了步数之后，就可以用 O(4×n)O(4\\times n)O(4×n) 的时间快速输出了，nnn 为边长。 因为题目给出的操作只能删除，而且要求回到最初的位置，所以向上、向下和向左、向右的数量应该就是一样的了，所以应该取最小值。 但是有一些特殊情况需要特判一下：当向上、向下或者向左、向右的数量有一个是 000 的时候并不是不可以的，要注意向左紧接着向右或者向上之后紧接着向下也是合法的。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=1e5+5; int n,s[5]; char a[N]; void solve(){ memset(s,0,sizeof(s)); int ans=0; cin&gt;&gt;a+1,n=strlen(a+1); for(int i=1;i&lt;=n;i++){ if(a[i]=='R') s[1]++; if(a[i]=='D') s[2]++; if(a[i]=='L') s[3]++; if(a[i]=='U') s[4]++; }ans+=min(s[1],s[3])*2; ans+=min(s[2],s[4])*2; if(min(s[1],s[3])==0&amp;&amp;min(s[2],s[4])==0){puts(&quot;0\\n&quot;);return;} if((min(s[1],s[3])==0)||(min(s[2],s[4])==0)){ if(min(s[1],s[3])==0) cout&lt;&lt;&quot;2\\nDU\\n&quot;; if(min(s[2],s[4])==0) cout&lt;&lt;&quot;2\\nLR\\n&quot;; return; } cout&lt;&lt;ans&lt;&lt;endl; for(int i=1;i&lt;=min(s[1],s[3]);i++) cout&lt;&lt;'R'; for(int i=1;i&lt;=min(s[2],s[4]);i++) cout&lt;&lt;'D'; for(int i=1;i&lt;=min(s[1],s[3]);i++) cout&lt;&lt;'L'; for(int i=1;i&lt;=min(s[2],s[4]);i++) cout&lt;&lt;'U'; puts(&quot;&quot;); }signed main(){ int T;cin&gt;&gt;T; while(T--) solve(); return 0; } ","link":"https://doittomorrow.xyz/post/snow-walking-robot-de-ti-jie/"},{"title":"「ABC217F」Make Pair 的题解","content":"题目大意 一共 2N2N2N 个学生站成一排，其中有 MMM 对朋友关系。老师每次从队列中挑出两个相邻的学生作为同桌。为了关系和睦，每次选出的两个学生必须是朋友关系。选出的两个学生离开队列，空出来的位置左右合拢。 请问老师有多少种方式选完所有学生？对于两种选人的方案，即使同桌关系相同，只要离开队列的顺序不同，也算是不同的方案，其中 1≤n≤2001\\le n\\le 2001≤n≤200。 思路 定义 fl,rf_{l,r}fl,r​ 表示将区间 [l,r][l,r][l,r] 全部消除的方案数。 考虑 rrr 与上一个区间的哪一个数配对： 如果 l,rl,rl,r 组合在一起，那么首先因该消除区间 [l+1,r−1][l+1,r-1][l+1,r−1]，转移方程为 fl,r=fl+1,r−1f_{l,r}=f_{l+1,r-1}fl,r​=fl+1,r−1​。 如果 k,rk,rk,r 组合在一起，那么将这个大区间拆分为两个小区间 [l,k−1][l,k-1][l,k−1] 和 [k+1,r][k+1,r][k+1,r]。因为两个区间是相对独立的，两个物件互不影响。那么如果左侧有 xxx 种方案，右侧有 yyy 种方案，那么总方案为 x×y×Cr−l+12r−k+12x\\times y \\times C_{\\frac{r-l+1}{2}}^{\\frac{r-k+1}{2}}x×y×C2r−l+1​2r−k+1​​。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=405,mod=998244353; int n,m,inv[N],jc[N],f[N][N]; bool a[N][N]; int ksm(int a,int b){ int ans=1; while(b){ if(b&amp;1) ans=(ans*a)%mod; a=(a*a)%mod; b&gt;&gt;=1; }return ans; } void init(){ inv[0]=jc[0]=1; for(int i=1;i&lt;N;i++){ jc[i]=(jc[i-1]*i)%mod; inv[i]=ksm(jc[i],mod-2); } } int c(int n,int m){ return ((jc[n]*inv[m])%mod*inv[n-m])%mod; } signed main(){ init(); cin&gt;&gt;n&gt;&gt;m; for(int i=1,x,y;i&lt;=m;i++){ cin&gt;&gt;x&gt;&gt;y; a[x][y]=a[y][x]=1; if(abs(x-y)==1) f[x][y]=f[y][x]=1; } n*=2; for(int len=3;len&lt;n;len+=2){ for(int l=1;l+len&lt;=n;l++){ int r=l+len; if(a[l][r]) f[l][r]=f[l+1][r-1]; for(int k=l+2;k&lt;r;k+=2){ if(a[k][r]) f[l][r]=(f[l][r]+(f[l][k-1]*f[k+1][r-1])%mod*c(len/2+1,(r-k+1)/2))%mod; } } } cout&lt;&lt;f[1][n]; return 0; } ","link":"https://doittomorrow.xyz/post/abc217f-make-pair-de-ti-jie/"},{"title":"[COCI2015-2016#6] PAROVI 的题解","content":"题意 选择一些 nnn 一下互质的二元组 {a,b}\\{a,b\\}{a,b}，求对于任意 x∈[2,n]x\\in \\big[2,n\\big]x∈[2,n] 都不满足 a,b&lt;xa,b&lt;xa,b&lt;x 和 a,b≥xa,b\\ge xa,b≥x 的个数。 简化题意 因为无解的情况只发生在所有的 {a,b}\\{a,b\\}{a,b} 之间没有多余的位置用于放置 xxx，所以题意可以抽象成这样： 选择一些区间互质的区间 [a,b][a,b][a,b] 覆盖 [1,n][1,n][1,n] 的方案数。 思路 设计 fi,jf_{i,j}fi,j​ 表示前 iii 个字符覆盖区间 [1,j][1,j][1,j] 的方案数。 对于 fi,jf_{i,j}fi,j​，有一下合法的操作： 不选择第 iii 个线段，即 fi,j=fi,j+fi−1,jf_{i,j}=f_{i,j}+f_{i-1,j}fi,j​=fi,j​+fi−1,j​。 选择第 iii 条线段并且第 iii 条线段的左端点可以覆盖到 jjj，即 fi,ri=fi,ri+fi−1,jf_{i,r_i}=f_{i,r_i}+f_{i-1,j}fi,ri​​=fi,ri​​+fi−1,j​。 选择第 iii 条线段并且第 iii 条线段的左端点不可以覆盖到 jjj，对答案覆盖的右端点没有贡献，即 fi,j=fi,j+fi−1,jf_{i,j}=f_{i,j}+f_{i-1,j}fi,j​=fi,j​+fi−1,j​。 假线段数量一共有 kkk 条，那么答案就是 fk,nf_{k,n}fk,n​，时间复杂度为 O(k×n)O(k\\times n)O(k×n)。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=405,mod=1e9; struct node{int x,y;}; vector&lt;node&gt; v; bool cmp(node a,node b){ if(a.y==b.y) return a.x&lt;b.x; return a.y&lt;b.y; }int n,f[N][30],ans; signed main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;i;j++) if(__gcd(i,j)==1) v.push_back({j,i}); sort(v.begin(),v.end(),cmp); f[0][1]=1; for(int i=1;i&lt;=v.size();i++){ for(int j=0;j&lt;=n;j++){ (f[i][j]+=f[i-1][j])%=mod; if(v[i-1].x&lt;=j&amp;&amp;j&lt;=v[i-1].y) (f[i][v[i-1].y]+=f[i-1][j])%=mod; if(j&lt;v[i-1].x) (f[i][j]+=f[i-1][j])%=mod; } }cout&lt;&lt;f[v.size()][n]; return 0; } ","link":"https://doittomorrow.xyz/post/coci2015-20166-parovi-de-ti-jie/"},{"title":"[COCI2006-2007#4] ZBRKA 的题解","content":"题目大意 在一个长度为 nnn 的排列中找出逆序对数量恰好为 ccc 的排列总数，其中 1≤n≤103,1≤c≤1041\\le n \\le 10^3,1\\le c \\le 10^41≤n≤103,1≤c≤104。 思路 考虑将 111 到 nnn 这些数从小到大一次填进去，因为每一次填入的数多是最大的，所以逆序对增加的数量只与其所在的位置相关，所以设计 fi,jf_{i,j}fi,j​ 表示前 iii 个数逆序对为 jjj 的方案数。 在填入第 iii 个数时因为前面的 111 到 i−1i-1i−1 都小于 iii，所以 iii 每向前移动一个位置，逆序对的数量就会增加 111。 因为 iii 的位置并没有限制，所以 fi,j=∑k=0i−1fi−1,j−kf_{i,j}=\\sum \\limits^{i-1}\\limits_{k=0} f_{i-1,j-k}fi,j​=k=0∑i−1​fi−1,j−k​。 这个方法的时间复杂度与空间复杂度都是 O(n×c2)O(n\\times c^2)O(n×c2) 的，无法通过此题，所以可以使用前缀和与滚动数组优化。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=1e4+5,mod=1e9+7; int n,c,f[N],ans; signed main(){ cin&gt;&gt;n&gt;&gt;c; f[0]=1; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=c;j++) f[j]=(f[j]+f[j-1])%mod; for(int j=c;j&gt;=i;j--){ f[j]=(f[j]-f[j-i]+mod)%mod; } }cout&lt;&lt;f[c]&lt;&lt;endl; return 0; } ","link":"https://doittomorrow.xyz/post/coci2006-20074-zbrka-de-ti-jie/"},{"title":"CCF考纲","content":"CCF考纲 CSP-J 程序基本概念1.0 标识符，关键字，常量，变量，字符串，表达式的概念 常量与变量的命名，定义及作用 头文件与名字空间的概念 编辑，编译，解释，调试的概念 基本数据类型 整数型：int，long long 实数型：float，double 字符型：char 布尔型：bool 程序基本语句 cin 语句，scanf 语句，cout 语句，printf 语句，赋值语句，复合语句 if 语句，switch 语句，多层条件语句 for 语句，while 语句，do while 语句 多层循环语句 基本运算 算术运算：加，减，乘，除，整除，求余 关系运算：大于，大于等于，小于， 小于等于，等于，不等于 逻辑运算：与（&amp;&amp;\\&amp;\\&amp;&amp;&amp;），或（∣∣||∣∣），非（!!!） 变量自增与自减运算 三目运算 位运算：与（&amp;\\&amp;&amp;），或（∣|∣），非（~）， 异或（^），左移（&lt;&lt;&lt;&lt;&lt;&lt;），右移（&gt;&gt;&gt;&gt;&gt;&gt;） 数学库常用函数 绝对值函数，四舍五入函数 下取整函数， 上取整函数 平方根函数，常用三角函数 对数函数，指数函数 结构化程序设计 顺序结构，分支结构和循环结构 自顶向下，逐步求精的模块化程序设计 流程图的概念及流程图描述 数组 数组与数组下标 数组的读入与输出 二维数组与多维数组 字符串的处理 字符数组与相关函数 string 类与相关函数 函数与递归 函数定义与调用，形参与实参 传值参数与传引用参数 常量与变量的作用范围 递归函数 结构体与联合体 结构体 联合体 指针类型 指针 基于指针的数组访问 字符指针 指向结构体的指针 文件及基本读写 文件的基本概念，文本文件的基本操作 文本文件类型与二进制文件类型 文件重定向，文件读写等操作 STL 模板 算法模板库中的函数：min，max，swap，sort 栈 （stack），队列 （queue），链表 （list），向量（vector）等容器 线性结构 链表：单链表，双向链表，循环链表 栈 队列 简单树 树的定义与相关概念 树的表示与存储 二叉树的定义与基本性质 二叉树的表示与存储 二叉树的遍历：前序，中序，后序 特殊树 完全二叉树的定义与基本性质 完全二叉树的数组表示法 哈夫曼树的定义和构造，哈夫曼编码 二叉搜索树的定义和构造 简单图 图的定义与相关概念 图的表示与存储：邻接矩阵 图的表示与存储：邻接表 算法概念与描述 算法概念 算法描述：自然语言描述，流程图描述， 伪代码描述 入门算法 枚举法 模拟法 基础算法 贪心法 递推法 递归法 二分法 倍增法 数值处理算法 高精度的加法 高精度的减法 高精度的乘法 高精度整数除以单精度整数的商和余数 排序算法 排序的基本概念 冒泡排序 选择排序 插入排序 计数排序 搜索算法 深度优先搜索 广度优先搜索 图论算法 深度优先遍历 广度优先遍历 泛洪算法（flood fill） 动态规划 动态规划的基本思路 简单一维动态规划 简单背包类型动态规划 简单区间类型动态规划 数及其运算 自然数，整数，有理数，实数及其算术运算（加，减，乘，除） 进制与进制转换：二进制，八进制， 十进制，十六进制 初等数学 代数（初中部分） 几何（初中部分） 初等数论 整除，因数，倍数，指数，质（素） 数， 合数 取整 模运算与同余 整数唯一分解定理 辗转相除法（欧几里得算法） 素数筛法：埃氏筛法与线性筛法 离散与组合数学 集合 加法原理 乘法原理 排列 组合 杨辉三角 其他 ASCII 码 格雷码 CSP-S 类（class） 类的概念及简单应用 成员函数和运算符重载 STL 模板 容器（container）和迭代器（iterator） 集合（set），多重集合（multiset） 双端队列（deque），优先队列（priority_queue） 映射（map），多重映射（multimap） 算法模板库中的常用函数 线性 结构 双端栈 双端队列 单调队列 优先队列 ST 表（Sparse Table） 集合与森林 并查集 树的孩子兄弟表示法 特殊 树 二叉堆 树状数组 线段树 字典树（Trie 树） 笛卡尔树 平衡树：AVL，treap，splay 等 常见图 稀疏图 偶图（二分图） 欧拉图 有向无环图 连通图与强连通图 双连通图 哈希表 数值哈希函数构造 字符串哈希函数构造 哈希冲突的常用处理方法 复杂度分析 时间复杂度分析 空间复杂度分析 算法策略 离散化 基础 算法 分治算法 排序 算法 归并排序 快速排序 堆排序 桶排序 基数排序 字符串相关算法 字符串匹配：KMP 算法 搜索 算法 搜索的剪枝优化 记忆化搜索 启发式搜索 双向广度优先搜索 迭代加深搜索 图论 算法 最小生成树：Prim和 Kruskal 等算法 次小生成树 单源最短路：Bellman-Ford，Dijkstra， SPFA 等算法 单源次短路 Floyd-Warshall 算法 有向无环图的拓扑排序 欧拉道路和欧拉回路 二分图的判定 强连通分量 割点，割边 树的重心，直径，DFS 序与欧拉序 树上差分，子树和与倍增 最近公共祖先 动态 规划 树型动态规划 状态压缩动态规划 动态规划的常用优化 初等 数学 代数（高中部分） 几何（高中部分） 初等 数论 同余式 欧拉定理和欧拉函数 费马小定理 威尔逊定理 裴蜀定理 模运算意义下的逆元 扩展欧几里得算法 中国剩余定理 离散与 组合数学 多重集合 等价类 多重集上的排列 多重集上的组合 错排列，圆排列 鸽巢原理 二项式定理 容斥原理 卡特兰（Catalan）数 线性代数 向量与矩阵的概念 向量的运算 矩阵的初等变换 矩阵的运算：加法，减法，乘法与转置 特殊矩阵的概念：单位阵，三角阵， 对称阵和稀疏矩阵 高斯消元法 NOI 线性结 构 块状链表 序列 跳跃表 复杂树 树链剖分 动态树：LCT 二维线段树 树套树 k-d 树 虚树 可合并堆 左偏树 二项堆 可持久化数据结构 可持久化线段树 其他可持久化数据结构 算法 策略 分块 离线处理思想 复杂分治思想 平衡规划思想 构造思想 字符串算法 Manacher 算法 扩展 KMP 算法 有穷自动机 AC 自动机 后缀数组 后缀树 后缀自动机 图论算 法 基环树 最小树形图 2-SAT 网络流 图的支配集，独立集与覆盖集 匈牙利算法 KM 算法 一般图的匹配 动态规 划 复杂动态规划模型的构建 复杂动态规划模型的优化 初等数 论 原根和指数 大步小步（Baby Step Giant Step，BSGS） 算法 狄利克雷（Dirichlet）卷积 二次剩余 二次同余式 离散与组 合数学 群及其基本性质 置换群与循环群 母函数 莫比乌斯反演 Burnside 引理与 Pólya 定理 斯特林（Stirling）数 无根树的 Prüfer 序列 线性 代数 逆矩阵 行列式 向量空间与线性相关 高等数学 多项式函数的微分 多项式函数的积分 泰勒（Taylor）级数 快速傅里叶变换 概率论 概率的基本概念 随机变量的期望与方差 条件概率 贝叶斯公式 博弈论 尼姆（Nim）博弈 SG 函数 最优化 单纯形法 计算几何 点，线，面之间位置关系的判定 一般图形面积的计算 二维凸包 半平面交 信息论 熵，互信息，条件熵，相对熵 其 他 信息复杂度的概念 描述复杂度的概念 通讯复杂度的概念 ","link":"https://doittomorrow.xyz/post/ccf-kao-gang/"},{"title":"CF1896E Permutation Sorting 的题解","content":"题目描述 给定一个有 111 至 nnn 组成的排列 a1,a2,⋯ ,ana_1,a_2,\\cdots ,a_na1​,a2​,⋯,an​。如果下标 i=aii=a_ii=ai​，则认为这个下标是好下标。现在每秒将不好的下标循环右移一位，求下标为 111 至 nnn 变为好下标的最早时刻。 思路 因为移动有环，所以将数组破环为链。 接着将对应点与目标点连线。 设 xxx 的最终移动位置为 sxs_xsx​，那么在 x→sxx\\to s_xx→sx​ 的过程中已经有 y→syy \\to s_yy→sy​ 到达了位置，那么 xxx 的移动次数就会减少 111，因为在 xxx 移动到 sys_ysy​ 这个位置是就直接跳过了。注意，在连线的时候，不光要处理 sx&lt;ns_x&lt;nsx​&lt;n 的连线，序列复制的部分也要处理。因此，对于 xxx 移动到 sxs_xsx​，就是 xxx 到 sxs_xsx​ 的距离减去 x→sxx\\to s_xx→sx​ 之间包含的区间的个数。 所以题目就转化成为了求解 nnn 个区间内包含的区间数，即满足 x&lt;yx&lt;yx&lt;y 且 sx&gt;sys_x&gt;s_ysx​&gt;sy​ 的 yyy 数量，也就是一个二位偏序问题。所以将 xxx 作为下标，将 sxs_xsx​ 作为具体值放入树状数组中进行求解。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; #define lowbit(x) x&amp;-x const int N=2e6+6; int n,a[N],s[N],l[N],r[N],x[N],ans[N]; void updata(int x){ for(int i=x;i&lt;=n*2;i+=lowbit(i)) s[i]++; }int sum(int x){ int ans=0; for(int i=x;i&gt;=1;i-=lowbit(i)) ans+=s[i]; return ans; } void solve(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++){ l[i]=i; if(a[i]&lt;i) r[i]=a[i]+n,r[i+n]=2e6; else r[i]=a[i],r[i+n]=a[i]+n; }//for(int i=2*n;i&gt;=1;i--) cout&lt;&lt;r[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; for(int i=n*2;i&gt;=1;i--){ //cout&lt;&lt;sum(x[i])&lt;&lt;&quot; &quot;; //cout&lt;&lt;r[i]&lt;&lt;&quot; &quot;&lt;&lt;i&lt;&lt;endl; if(i&lt;=n) ans[a[i]]=r[i]-l[i]-sum(r[i]); //cout&lt;&lt;sum(r[i])&lt;&lt;&quot; &quot;&lt;&lt;r[i]&lt;&lt;endl; updata(r[i]); }for(int i=1;i&lt;=n;i++) cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; for(int i=1;i&lt;=n*2;i++) a[i]=s[i]=l[i]=x[i]=ans[i]=0; }signed main(){ int T;cin&gt;&gt;T; while(T--) solve(); return 0; } ","link":"https://doittomorrow.xyz/post/cf1896e-permutation-sorting-de-ti-jie/"},{"title":"[COCI2022-2023#4] Vrsta 的题解","content":"题目描述 有一个序列，初始为空。 有 nnn 次操作，每次添加 kkk 个值为 aaa 的数到序列中。 对于每次操作，你需要输出当前序列的中位数，中位数有 222 个输出较小的一个。其中 1≤n≤2×1051\\le n\\le 2\\times 10^51≤n≤2×105，1≤ai≤1091 \\le a_i \\le 10^91≤ai​≤109。 思路 因为对于一个数 xxx，其中有小于 xxx 的书的个数大于 12n\\frac{1}{2} n21​n 而且对于任意小于 xxx 的数都不成立，那么这个数就是这个序列的中位数，所以这道题目可以使用二分求解。为了快速统计一个序列中小于 xxx 的数的个数，可以使用树状数组。将输入在离散化之后一次插入树状数组即可。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=2e5+5; int n,cnt,ans; struct edge{int x,id;}b[N]; struct node{int x,num;}a[N]; bool cmp(edge a,edge b){return a.x&lt;b.x;}; struct rmq{ int s[N]; #define lowbit(x) x&amp;-x void updata(int x,int v){ for(int i=x;i&lt;=n;i+=lowbit(i)) s[i]+=v; }int sum(int x){ int ans=0; for(int i=x;i&gt;=1;i-=lowbit(i)) ans+=s[i]; return ans; } }x; bool ck(int mid){ if(x.sum(mid)&gt;=cnt/2+(cnt%2!=0)) return 1; return 0; } signed main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++){ cin&gt;&gt;a[i].x&gt;&gt;a[i].num; b[i].x=a[i].x,b[i].id=i; }sort(b+1,b+1+n,cmp); for(int i=1;i&lt;=n;i++) a[b[i].id].x=i; for(int i=1;i&lt;=n;i++){ x.updata(a[i].x,a[i].num),cnt+=a[i].num; int l=1,r=n; while(l&lt;=r){ int mid=(l+r)/2; if(ck(mid)) ans=mid,r=mid-1; else l=mid+1; }cout&lt;&lt;b[ans].x&lt;&lt;endl; }return 0; } ","link":"https://doittomorrow.xyz/post/coci2022-20234-vrsta-de-ti-jie/"},{"title":"CF1335F 题解","content":"题目大意 给出一个 n×mn\\times mn×m 的网格，每个格子被染成黑色或白色，并且在每个格子上都有一个方向。你可以在一些格子中放置机器人，但要求所有的格子内的机器人均可以一直走走下去，一直不与其他机器人相撞。要求在满足上述条件的情况下使得机器人数量和机器人占据的黑格数量均最多。 思路 因为格子的数量是有限的，而机器人却需要重复无限次的行走，所以显然所有的机器人在最后都会汇聚到环上。因为整个图的可以行走的格子数量不会超过 n×mn\\times mn×m，所以在机器人行走 n×mn\\times mn×m 步之后，所有应该重复的机器人应该已经重合了。 所以我们假设所有的格子在一开始都有机器人，那么在走了 n×mn\\times mn×m 步之后，所有应该相遇的机器人应该已经全部相遇了。如果在最后有机器人相遇了，那么就说明这些格子只能放置一个机器人。因为需要将黑色格子放置的机器人最大化，那么如果有来自黑色格子的机器人，那么就将这个格子让给黑色格子的机器人。 因为要模拟 n×mn\\times mn×m 个机器人走 n×mn\\times mn×m 步，所以直接模拟会超时，需要考虑倍增。预处理出数组 fff，其中 fi,jf_{i,j}fi,j​ 表示编号为 iii 的机器人走 2j2^j2j 步到达的格子。 这样就可以快速的知道在 n×mn\\times mn×m 秒后的答案，时间复杂度为 O(nmlog⁡n)O(nm\\log n)O(nmlogn)。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=1e6+5; int t,n,m,c[N],f[N][22],cnt[N][2]; char a[N]; void solve(){ cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++){ cin&gt;&gt;a; for(int j=0;j&lt;m;j++) c[i*m+j]=a[j]; }for(int i=0;i&lt;n;i++){ cin&gt;&gt;a; for(int j=0;j&lt;m;j++){ if(a[j]=='U') f[i*m+j][0]=(i-1)*m+j; if(a[j]=='D') f[i*m+j][0]=(i+1)*m+j; if(a[j]=='L') f[i*m+j][0]=i*m+j-1; if(a[j]=='R') f[i*m+j][0]=i*m+j+1; } }for(int i=0;i&lt;n*m;i++) cnt[i][0]=cnt[i][1]=0; int p=log2(n*m)+1; for(int i=1;i&lt;=p;i++){ for(int j=0;j&lt;n*m;j++){ f[j][i]=f[f[j][i-1]][i-1]; } }for(int i=0;i&lt;n*m;i++){ int k=f[i][p]; if(c[i]==48) cnt[k][0]++; else cnt[k][1]++; }int ans1=0,ans2=0; for(int i=0;i&lt;n*m;i++){ if(cnt[i][0]||cnt[i][1]) ans1++; if(cnt[i][0]) ans2++; }cout&lt;&lt;ans1&lt;&lt;&quot; &quot;&lt;&lt;ans2&lt;&lt;endl; } signed main(){ int T;cin&gt;&gt;T; while(T--) solve(); return 0; } ","link":"https://doittomorrow.xyz/post/cf1335f-ti-jie/"},{"title":"[ICPC2016 WF] Swap Space 的题解","content":"题目大意 给你 nnn 个硬盘，第 iii 个硬盘原来有 aia_iai​ 的内存，但是在转化格式之后内存就变成了 bib_ibi​。在转化格式的时候，全部的资料都需要转移到其他空间，如果空间不够用就可以额外申请空间。在最开始的时候每个硬盘都装满了，求额外申请的空间的最小值。 思路 首先所有的硬盘一共与三种分类：ai&lt;bia_i&lt;b_iai​&lt;bi​，ai=bia_i=b_iai​=bi​，ai&gt;bia_i&gt;b_iai​&gt;bi​。 因为第 222 类对于答案没有影响，所以为了便于处理，我们将第 222 类归入第一类，即 ai≤bia_i\\le b_iai​≤bi​，ai&gt;bia_i&gt;b_iai​&gt;bi​。 应该优先处理第 111 类，因为在修改之后剩余的空间是在增加的。 对于第 111 类，应该按 aia_iai​ 从小到大处理更优，证明如下： 假设有 222 块硬盘分别是 (a1,b1)(a_1,b_1)(a1​,b1​) 和 (a2,b2)(a_2,b_2)(a2​,b2​)。 如果 $b_1\\ge a_2 $：先处理 a1a_1a1​ 再处理 a2a_2a2​，需要的代价是 a1a_1a1​；先处理 a2a_2a2​ 再处理 a1a_1a1​，需要的代价是 a2a_2a2​。因为 a1≤a2a_1\\le a_2a1​≤a2​，所以先处理第 111 块更优。 如果 b1&lt;a2b_1&lt; a_2b1​&lt;a2​：先处理 a1a_1a1​ 再处理 a2a_2a2​，需要的代价是 a1+a2−b1a_1+a_2-b_1a1​+a2​−b1​；先处理 a2a_2a2​ 再处理 a1a_1a1​，需要的代价是 a2a_2a2​。因为a1+a2−b1≤a2a_1+a_2-b_1\\le a_2a1​+a2​−b1​≤a2​，所以先处理第 111 块更优。 对于第 222 类，应该按 bib_ibi​ 从大到小处理更优，证明如下： 假设有 222 块硬盘分别是 (a1,b1)(a_1,b_1)(a1​,b1​) 和 (a2,b2)(a_2,b_2)(a2​,b2​)。 如果 $b_1\\ge a_2 $：先处理 a1a_1a1​ 再处理 a2a_2a2​，需要的代价是 a1a_1a1​；先处理 a2a_2a2​ 再处理 a1a_1a1​，需要的代价是 a2+a1−b2a_2+a_1-b_2a2​+a1​−b2​。因为 a1≤a2+a1−b2a_1\\le a_2+a_1-b_2a1​≤a2​+a1​−b2​，所以先处理第 111 块更优。 如果 b1&lt;a2b_1&lt; a_2b1​&lt;a2​：先处理 a1a_1a1​ 再处理 a2a_2a2​，需要的代价是 a1+a2−b1a_1+a_2-b_1a1​+a2​−b1​；先处理 a2a_2a2​ 再处理 a1a_1a1​，需要的代价是 a2+a1−b2a_2+a_1-b_2a2​+a1​−b2​。因为a1+a2−b1≤a2+a1−b2a_1+a_2-b_1\\le a_2+a_1-b_2a1​+a2​−b1​≤a2​+a1​−b2​，所以先处理第 111 块更优。 所以，排序之后模拟整个过程，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=1e6+5; int n,c1,c2,ans,cnt; struct node{int a,b;}s1[N],s2[N]; bool cmp1(node x,node y){return x.a&lt;y.a;} bool cmp2(node x,node y){return x.b&gt;y.b;} signed main(){ cin&gt;&gt;n; for(int i=1,a,b;i&lt;=n;i++){ cin&gt;&gt;a&gt;&gt;b; if(a&lt;b) s1[++c1]={a,b}; else s2[++c2]={a,b}; }sort(s1+1,s1+1+c1,cmp1),sort(s2+1,s2+1+c2,cmp2); for(int i=1;i&lt;=c1;i++){ if(cnt&lt;s1[i].a) ans+=(s1[i].a-cnt),cnt=0; else cnt-=s1[i].a; cnt+=s1[i].b; }for(int i=1;i&lt;=c2;i++){ if(cnt&lt;s2[i].a) ans+=(s2[i].a-cnt),cnt=0; else cnt-=s2[i].a; cnt+=s2[i].b; }cout&lt;&lt;ans&lt;&lt;endl; return 0; } ","link":"https://doittomorrow.xyz/post/icpc2016-wf-swap-space-de-ti-jie/"},{"title":"[ABC236D] Dance 题解","content":"题目大意 有 2n2n2n 个人，每第 iii 个人与第 jjj 个人一组会产生 ai,ja_{i,j}ai,j​ 的价值，求所有价值异或的最大值，其中 1≤n≤81\\le n \\le 81≤n≤8。 思路 因为 nnn 的数据范围十分人性，所以可以使用 dfs 进行包搜通过这道题目。 在函数中传入两个参数 xxx 与 sss 分别表示现在正在选择的人与获得的价值。 当 x=2×n+1x=2\\times n+1x=2×n+1 时，说明前面的 2×n2\\times n2×n 个人已经全部访问完了，就应该储存答案接着返回了。 为了使选择的人不重复，应该使用 visvisvis 数组记录已经选择的人，避免重复选择。 要注意，在操作中 xxx 这个人不光可以选择别人还可以被别人选择，所以应该有直接访问下一层的操作。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=100; int n,a[N][N],ans; bool vis[N]; void dfs(int x,int s){ if(x==n+1){ for(int i=1;i&lt;=n;i++) if(!vis[i]) return ; ans=max(ans,s); return; }if(vis[x]){dfs(x+1,s);return;} //已经被前面的人选择过了 vis[x]=1; for(int i=1;i&lt;x;i++){ if(!vis[i]){ vis[i]=1; dfs(x+1,s^a[min(x,i)][max(x,i)]); //因为输入的时候 j 全部大于 i vis[i]=0; } }vis[x]=0,dfs(x+1,s); //给别人选择自己的机会 } void solve(){ cin&gt;&gt;n; n*=2; for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) cin&gt;&gt;a[i][j]; dfs(1,0); cout&lt;&lt;ans&lt;&lt;endl; }signed main(){ int T=1;//cin&gt;&gt;T; while(T--) solve(); return 0; } ","link":"https://doittomorrow.xyz/post/abc236d-dance-ti-jie/"},{"title":"[ABC144E]Gluttony 的题解","content":"题目大意： 有两个数组 aia_iai​ 和 fif_ifi​，任意选取若干个 aia_iai​ 使他们一共减少的数量在不超过 kkk 的情况下，任意将 aaa 数组与 fff 中的元素进行匹配，使两两间的乘积的最大值最小。 分析 首先考虑 k=0k=0k=0 的情况：对于任意的 ai&lt;aja_i&lt;a_jai​&lt;aj​，fx&lt;fyf_x&lt;f_yfx​&lt;fy​，可以发现 max⁡(ai×fy,aj×fx)≤max⁡(ai×fy,aj×fx)\\max(a_i\\times f_y,a_j\\times f_x)\\le \\max(a_i\\times f_y,a_j\\times f_x)max(ai​×fy​,aj​×fx​)≤max(ai​×fy​,aj​×fx​)。所以将 aaa 数组升序排列，将 fff 数组降序排列，一一对应就是最优的情况了。 因为减少的量越大获得乘积的最大值越小，所以这个问题具有单调性，可以使用二分进行求解。 可以二分乘积的最大值最小值，通过最小值与 fif_ifi​ 求解出如果需要满足这个最小值 aia_iai​ 的最大值，计算出需要更改的数量，并判断是否小于 kkk，即满足 ∑i=1n⌈Ai×Fi−xFi⌉&lt;k\\sum_{i=1}^n\\lceil \\frac{A_i \\times F_i-x}{F_i} \\rceil &lt;k∑i=1n​⌈Fi​Ai​×Fi​−x​⌉&lt;k。 AC Code #include&lt;bits/stdc++.h&gt; #define ceil(a,b) a/b+(a%b!=0) #define int long long using namespace std; const int N=2e5+5; int n,k,a[N],f[N],l=0,r=1e18,ans=-1,s[N]; bool cmp(int a,int b){ return a&gt;b; } bool ck(int x){ int cnt=0; for(int i=1;i&lt;=n;i++){ int sb=a[i]*f[i]; if(sb&gt;x) cnt+=ceil((sb-x),f[i]); } return (cnt&lt;=k); } signed main(){ cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; for(int i=1;i&lt;=n;i++) cin&gt;&gt;f[i]; sort(a+1,a+1+n),sort(f+1,f+1+n,cmp); while(l&lt;=r){ int mid=(l+r)/2; if(ck(mid)){ r=mid-1; ans=mid; }else l=mid+1; }cout&lt;&lt;ans&lt;&lt;endl; return 0; } ","link":"https://doittomorrow.xyz/post/abc144egluttony-de-ti-jie/"},{"title":"Tavas and Malekas 的题解","content":"传送门 题目大意 文本串长度为 nnn，给你模式串在文本串中出现的 mmm 个位置（必须在这些位置有出现过，也可以在其他位置出现），求可能的文本串数量，其中 1≤n≤1061\\le n \\le 10^61≤n≤106 而且 0≤m≤n−∣p∣+10 \\le m \\le n-|p|+10≤m≤n−∣p∣+1。 思路 简化 首先我们可以考虑如果输入保证合法，那么因为字符串都是小写字母，所以答案就是 26num26^{num}26num，numnumnum 指没有被标记过的数量。 但是如果将访问过的位置全部标记出来最坏的情况下会多次重复的标记应景标记的位置，所以还是会超时。这个时候我们可以考虑优化。 因为输入的位置保证单调增，所以在标记的一开始就可以从 max⁡(ai,ai−1+len)\\max(a_i,a_{i-1}+len)max(ai​,ai−1​+len) 开始，有效避免重复标记。 分析 如果我们需要判断合法的话，那么我们就需要将重复的部分依次比对。 所以将时间复杂度拖慢的主要部分就是比较，所以考虑将比较优化了，可以使用字符串哈希。 因为我们比较的都是上一个字符串的后缀和这一个字符串的前缀，所以只需要比较前缀与后置哈希就可以了。 首先，我们先预处理出 ppp 数组，其中 pip_ipi​ 表示 113i113^i113i 次方，注意这里的 113113113 就是哈希秘钥。 p[0]=1; for(int i=1;i&lt;=len;i++) p[i]=(p[i-1]*113)%mod; 接着，处理处字符串的前缀数组。 for(int i=1,v=s[i]-'a';i&lt;=len;i++,v=s[i]-'a') front[i]=(front[i-1]*113+v)%mod; 最后将后缀数组也处理了。 注意因为要与前缀相比较，所以哈希值应该与前缀的顺序相同，也就是需要倒序枚举。 for(int i=len,v=s[i]-'a';i&gt;=1;i--,v=s[i]-'a') back[i]=(back[i+1]+v*p[len-i])%mod; 接着在循环中就只需要判断前缀哈希与后缀哈希是否相同就好了。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=1e6+5,mod=1e9+7,INF=1e18; char ch; int ksm(int a,int b){ //求解 a^b int ans=1; while(b){ if(b&amp;1) ans=ans*a%mod; a=a*a%mod; b&gt;&gt;=1; }return ans; } int n,m,a[N]={-INF}; //将 a[0] 设为极小值，保证第一次覆盖完全 char s[N]; int front[N],back[N],p[N],len,ans; bool vis[N]; signed main(){ cin&gt;&gt;n&gt;&gt;m; cin&gt;&gt;s+1,len=strlen(s+1); p[0]=1; for(int i=1;i&lt;=len;i++) p[i]=(p[i-1]*113)%mod; for(int i=1,v=s[i]-'a';i&lt;=len;i++,v=s[i]-'a') front[i]=(front[i-1]*113+v)%mod; for(int i=len,v=s[i]-'a';i&gt;=1;i--,v=s[i]-'a') back[i]=(back[i+1]+v*p[len-i])%mod; for(int i=1;i&lt;=m;i++){ cin&gt;&gt;a[i]; if(a[i-1]+len&gt;a[i]&amp;&amp;back[a[i]-a[i-1]+1]!=front[a[i-1]+len-a[i]]) cout&lt;&lt;0,exit(0); for(int j=max(a[i],a[i-1]+len);j&lt;a[i]+len;j++) vis[j]=1; }for(int i=1;i&lt;=n;i++) ans+=(!vis[i]); cout&lt;&lt;ksm(26,ans)&lt;&lt;endl; return 0; } ","link":"https://doittomorrow.xyz/post/tavas-and-malekas-de-ti-jie/"},{"title":"[Atcoder DP I]Coins 题解","content":"题目大意 NNN 枚硬币，第 iii 枚硬币有 pip_ipi​ 的概率正面朝上，有 1−pi1-p_i1−pi​ 的概率反面朝上。 扔完所有硬币，求正面朝上的银币数比反面朝上的银币数多的概率，其中 N≤2999N\\le 2999N≤2999。 思路 显而易见的这道题目是一个 DP，绝对不是因为它是 DP 列表里的题目。因为题目中的 N≤2999N\\le 2999N≤2999 所以可以考虑 n2n^2n2 的DP 程序。 设 fi,jf_{i,j}fi,j​ 表示正面有 iii 个硬币，反面有 jjj 个硬币的概率。 得到有 iii 个正面，jjj 个反面只有可能是由 i−1i-1i−1 个正面与 jjj 个反面通过投掷一个正面或者 iii 个正面与 j−1j-1j−1 个反面通过投掷一个反面得到的。 所以 fi,j=fi−1,j×pi+j+fi,j−1×(1−pi+j)f_{i,j}=f_{i-1,j}\\times p_{i+j}+f_{i,j-1}\\times (1-p_{i+j})fi,j​=fi−1,j​×pi+j​+fi,j−1​×(1−pi+j​)。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int N=3005; int n; double p[N],f[N][N],ans; signed main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;p[i]; f[0][0]=1.0; for(int i=1;i&lt;=n;i++){ f[i][0]=f[i-1][0]*p[i]; f[0][i]=f[0][i-1]*(1-p[i]); } for(int i=1;i&lt;=n;i++){ for(int j=1;j+i&lt;=n;j++){ f[i][j]=f[i-1][j]*p[i+j]+f[i][j-1]*(1-p[i+j]); } } for(int i=n/2+1;i&lt;=n;i++){ ans+=f[i][n-i]; }printf(&quot;%.10lf&quot;,ans); return 0; } ","link":"https://doittomorrow.xyz/post/atcoder-dp-icoins-ti-jie/"},{"title":"[HNOI2005] 狡猾的商人's 题解","content":"题目描述 给你一个nnn元一次方程，判断是否有解，方程给出的格式为 a−b=ca-b=ca−b=c 思路 这道题看上去是一道题目看上去就是判断给出条件是否有矛盾，所以就自然而然的可以使用带权并查集 但是因为我太懒了并且这道题目要求使用差分约束系统进行求解，于是就需要将题目转化一下 因为差分约束系统只能处理不等量关系，所以就需要使用一个不等式组进行表示，并且这个不等式组只能有一个解 于是就可以将 a−b=ca-b=ca−b=c 转化为{a−b≤ca−b≥c\\begin{cases}a-b\\le c \\\\a-b \\ge c\\end{cases}{a−b≤ca−b≥c​ 但是在差分约束系统只能处理 ≤\\le≤ 的情况，所以不等式组就转化成了{a−b≤cb−a≤−c\\begin{cases}a-b\\le c \\\\b-a \\le -c\\end{cases}{a−b≤cb−a≤−c​， 于是在输入之后就可以这样储存了： v[a-1].push_back({b,c}),v[b].push_back({a-1,-c}); 注意: aaa 应该−1-1−1，否则就将 aaa 这个月漏算了 AC Code #include&lt;bits/stdc++.h&gt; inline int read(){ //没有大用的快读 int x=0,f=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9'){ if(ch=='-') f=-1; ch=getchar(); }while(ch&gt;='0'&amp;&amp;ch&lt;='9'){ x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); }return x*f; }int T,n,m,cnt[1001],dis[1001]; bool vis[1001]; struct node{ int k; //到达的点 int num; //代价 }; std::vector&lt;node&gt; v[1001]; //因为本人太懒，所以使用vector储存||v[i]表示从i出发的节点 inline bool spfa(int s){ std::queue&lt;int&gt; q; memset(dis,0x3f,sizeof(dis)); //多测不清空,爆零见祖宗 memset(vis,0,sizeof(vis)); memset(cnt,0,sizeof(cnt)); dis[s]=0; //初始化 vis[s]=1; q.push(s); while(!q.empty()){ int top=q.front(); q.pop(); vis[top]=0; for(node i:v[top]){ if(dis[i.k]&gt;dis[top]+i.num){ //差分约束系统跑的是最长路 dis[i.k]=dis[top]+i.num; if(!vis[i.k]){ q.push(i.k); vis[i.k]=1; cnt[i.k]++; if(cnt[i.k]&gt;n) //有负权环 return 0; } } } }return 1; }int main(){ T=read(); while(T--){ n=read(),m=read(); for(int i=1,a,b,c;i&lt;=m;++i){ a=read(),b=read(),c=read(); v[a-1].push_back({b,c}); //储存不等式 v[b].push_back({a-1,-c}); }bool flag=1; for(int i=0;i&lt;=n;++i){ if(spfa(i)==0){ flag=0; break; } }if(flag==1) puts(&quot;true&quot;); else puts(&quot;false&quot;); for(int i=0;i&lt;=m;i++) //多测不彻底清空=10pts v[i].erase(v[i].begin(),v[i].end()); }return 0; } ","link":"https://doittomorrow.xyz/post/hnoi2005-jiao-hua-de-shang-ren-s-ti-jie-chai-fen-yue-shu-xi-tong/"},{"title":"P1262 间谍网络 题解","content":"题目描述 给你一个有向图，可以付出代价获取一些指定的点。 在获取之后要求能以获取的点为出发点，将整个图都访问到，求最小的代价。 思路 既然需要令总的代价最少，那么如果通过买一个点就可以访问到的所有点，自然会比买两个点的方案更优。 于是自然的就可以联想到可以将图划分成很多个强连通图，只要在这个图中有一个点访问到了，整个强连通图就被访问到了。 既然要求强连通图，那么就自然的需要用到tarjan算法了。 再求出图内的所用强连通图之后对它们进行缩点，这样就只要能访问这个点就可以了。 但是因为在缩点之后就不能简单的遍历这个强连通图，所以我们就需要将这个强连通图中代价最小的一个点记录下来。 这就需要使用一个辅助数组 min_cost 来记录。 具体的实现也很简单，只需要在将栈内的元素弹出时进行比较就可以了。 AC Code #include&lt;bits/stdc++.h&gt; using namespace std; int n,r,p,dfn[3200],low[3200],group[320![](https://doittomorrow.xyz/post-images/1704207640718.jpg)0],in[3200],cost[3200],cnt,num,min_cost[3200],ans; bool vis[3200]; vector&lt;int&gt; v[3200]; stack&lt;int&gt; s; void tarjan(int x){ //tarjan的板子+缩点 dfn[x]=low[x]=++num; vis[x]=1; s.push(x); for(int i:v[x]){ //依次便利v[x]中的元素赋值给i if(!dfn[i]){ tarjan(i); low[x]=min(low[x],low[i]); }else if(vis[i]) low[x]=min(low[x],dfn[i]); }if(dfn[x]==low[x]){ //如果有环 group[x]=++cnt; min_cost[cnt]=cost[x]; vis[x]=0; while(s.top()!=x){ //栈内有强连通图内的元素 group[s.top()]=cnt; min_cost[cnt]=min(min_cost[cnt],cost[s.top()]); vis[s.top()]=0; s.pop(); }s.pop(); }return ; }int find(int x){ //寻找这个强连通图内最小的点 for(int i=1;i&lt;=n;i++) if(group[i]==x) return i; return n; }int main(){ memset(cost,0x3f,sizeof(cost)); //区分是否可以买 cin&gt;&gt;n&gt;&gt;p; for(int i=1,a,b;i&lt;=p;i++){ cin&gt;&gt;a&gt;&gt;b; cost[a]=b; }cin&gt;&gt;r; for(int i=1,a,b;i&lt;=r;i++){ cin&gt;&gt;a&gt;&gt;b; v[a].push_back(b); //标记可以通过a直接访问到b }for(int i=1;i&lt;=n;i++){ if(!dfn[i]&amp;&amp;cost[i]!=0x3f3f3f3f3f) //要判断是否可以买 tarjan(i); }for(int i=1;i&lt;=n;i++){ for(int j:v[i]){ //依次便利v[i]中的元素赋值给i if(group[j]!=group[i]) in[group[j]]++; } }for(int i=1;i&lt;=cnt;i++){ if(in[i]==0){ //因为入度为0，所以访问到这个具相当于将这一坨都购买了，比买有入度的点划算 ans+=min_cost[i]; if(min_cost[i]==0x3f3f3f3f){ //如果这个区间都不能买就不行 cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; cout&lt;&lt;find(i)&lt;&lt;endl; return 0; } } }cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; cout&lt;&lt;ans&lt;&lt;endl; return 0; } ","link":"https://doittomorrow.xyz/post/p1262-jian-die-wang-luo-s-ti-jie/"},{"title":"[ABC328D] Take ABC 题解","content":"题目翻译 题目描述 给你一个字符串 SSS 包含 A、B 和 C 三个不用的字符。 只要字符串 SSS 中包含连续的 ABC 就将 ABC 删除掉 再字符串 SSS 不能操作之后输出这个字符串 限制 SSS 的长度小于 2×1052 \\times 10^52×105 思路1 总结一下这道题目的操作，可以发现就是将字符串删除一部分接着将剩下的部分合并，这不是链表的操作吗。 就直接扫描字符串，如果出现了连续的 ABC 就将其删除。 接着因为删除了这个连续的 ABC 之后，肯能会有新出现的 ABC 连接在一起，所以在最坏的情况下就需要向前回溯两个字符。 但是在回溯的时候需要注意一个细节那就是上一个可能就是第一个了，如果继续回溯就会RE。 #include&lt;bits/stdc++.h&gt; char a[200005]; int n; int nex[200005]; //储存第i个元素的下一个元素 int fr[200005]; //储存第i个元素的上一个元素 int head=1; //储存第一个元素 int main(){ scanf(&quot;%s&quot;,a); n=strlen(a); for(register int i=n;i&gt;=1;i--) a[i]=a[i-1]; for(register int i=1;i&lt;=n;i++) nex[i]=i+1; for(register int i=2;i&lt;=n;i++) fr[i]=i-1; nex[n+1]=-1; //标记链表结尾 for(register int i=head;nex[i]!=-1&amp;&amp;nex[nex[i]]!=-1&amp;&amp;nex[nex[nex[i]]]!=-1;){ if(a[i]=='A'&amp;&amp;a[nex[i]]=='B'&amp;&amp;a[nex[nex[i]]]=='C'){ //如果满足要求 nex[fr[i]]=nex[nex[nex[i]]]; //删除这三个元素 fr[nex[nex[nex[i]]]]=fr[i]; if(i==head){ //如果上一个就是头 head=nex[nex[nex[i]]]; continue; }if(fr[i]==head) i=head; else i=fr[fr[i]]; continue; }i=nex[i]; }for(register int i=head;nex[i]!=-1;i=nex[i]) putchar(a[i]); //将剩余的输出 return 0; } 思路2 其实这道题目之所以使用普通数组会超时，是因为在删除后将后面的元素向前转移会划分很多时间。 那么只要后面呢没有元素，就不会存在向前移动导致花费大量时间的问题了。 因为每一次删除操作只会影响前后 222 个字符，所以可以考虑使用栈进行求解。 每次入一个元素入栈，如果站内的元素个数大于 333 个，就查看最后 333 个元素是否是 ABC。 如果是就将其删除，否则继续插入元素。 #include&lt;bits/stdc++.h&gt; using namespace std; string s; char q[200010]; int top; int main(){ cin&gt;&gt;s; for(int i=0;i&lt;s.size();i++){ //将元素一次插入栈中 q[++top]=s[i]; if(top&gt;2&amp;&amp;q[top]=='C'&amp;&amp;q[top-1]=='B'&amp;&amp;q[top-2]=='A') top-=3; //一定要判断元素的个数，否则会RE }for(int i=1;i&lt;=top;i++) cout&lt;&lt;q[i]; //将栈内的元素一次输出 return 0; } 总结 其实这两种方法的本质都是一样的，只是的具体实现方法不一样。 链表的思维难度没有栈的做法高，但是对码力的要求与效率比栈要高一点。 ","link":"https://doittomorrow.xyz/post/abc328d-take-abc-ti-jie/"},{"title":"如何正确的写文章（转载自洛谷）","content":"本文将会对 Markdown 和 LaTeX 的语法进行深入解读，旨在教会阅读本文的读者正确使用 Markdown 和 LaTeX 书写博客或题解。 本文将会通过正反对比的方式，指出一些做法的错误之处，并给出相应的正确做法。 笔者假设将要读本文的读者已经掌握了 Markdown 和 LaTeX 的语法。如果您还不熟悉的话，建议先查阅末尾 Reference 部分的资料。 接下来进入正题。 1 一些基本格式要求 这里是一些非常基本的格式要求，适用于任何格式的文本文档。 请在每句话的末尾添加句号； 请正确使用标点符号，注意区分全角符号与半角符号的使用（汉语请使用全角符号，英语请使用半角符号）； 中文与西文字符或公式之间以一个半角空格隔开，但标点符号与西文字符或公式间不要加空格。 下面是一些错误示范： 然而即使这样优化后它看上去还是十分辣手（违反 1.1） 众所周知,生存还是死亡,这是个问题.（违反 1.2） 该算法的时间复杂度为O(n2)O(n^2)O(n2)，无法通过n≤105n \\leq 10^5n≤105的数据，需要使用Dijkstra的堆优化算法。（违反 1.3） 我们来修正一下： 然而即使这样优化后它看上去还是十分辣手。 众所周知，生存还是死亡，这是个问题。 该算法的时间复杂度为 O(n2)O(n^2)O(n2)，无法通过 n≤105n \\leq 10^5n≤105 的数据，需要使用 Dijkstra 的堆优化算法。 2 在正确的地方，用正确的语言 如果你的题解要公开让其他人看到，请顾及他人感受。 以下几点是不提倡的： 出现不友好的语言（尤其是入门题）； 代码中出现大块的预编译指令； 分析内容过少（尤其是需要推导的数学题以及模板题）； 啰嗦太多无关的废话。 下面是错误示范。 这是一道大水题！其他的题解咋都写那么烂！（违反 2.1） 这个题目是一个数学题，打表可以发现答案是 a×b−a−ba \\times b - a - ba×b−a−b。（违反 2.3） 先让我吐槽一下背景和数据（中间省略 251251251 字）。（违反 2.4） 3 标题的使用 标题是引导文章结构的，不是用来强调的。 因此请不要用标题把字弄的很大，达到强调的目的。 下面是错误示范（为了不破坏文章 TOC，把错误示范用代码块框了起来）： # 这是一道非常水的题！！！ ## 我们可以用贪心来解决本题。 # 求管理员审核通过 QAQ 同样的道理，大段的加粗强调也是不合适的。强调的目的是让读者找到重点，如果全是重点，那和没有重点又有什么区别呢？ 4 列表的食用方式 4.1 无序列表 Markdown 中的无序列表可以用 *，-，+ 表示，并且它们都是等价的。 - QAQ - QwQ - QvQ 显示的效果是（把前面的 - 换成 * 和 + 渲染效果一样）： QAQ QwQ QvQ 当然，+ 号用的较少，这里不推荐大家使用。 在 - 和 * 中，因为 * 已经担当了较多的用途（包括加粗，斜体等），为了防止歧义，推荐大家用 - 表示无序列表。 4.2 有序列表 下面的形式描述了一个有序列表： 1. QAQ 2. QwQ 3. QvQ 显示的效果是： QAQ QwQ QvQ 下面也是一种比较推荐的有序列表写法。 1. QAQ 1. QwQ 1. QvQ 它的渲染效果是： QAQ QwQ QvQ 5 代码框 5.1 一般要求 使用代码框时，请标上代码的语言，以正确地渲染代码。 对于非代码部分，语言可以设置为 plain，避免错误地高亮。 5.2 代码可读性要求 人与人之间的代码风格差异还是挺大。不过题解对代码风格的要求并不高，只需要可读性好即可。 对于注释，需要避免注释喧宾夺主。 下面是一个典型的注释喧宾夺主的例子（/* */ 注释的部分指出问题所在）： #include&lt;bits/stdc++.h&gt;//万能头文件 /* 这个头文件是万能头文件很重要吗？ */ using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);//优化cin,cout,险些TLE。 /* 同前。 */ int a[100005],n; cin&gt;&gt;n; // 输入礼物数。 /* 题目输入格式里已经把输入的每个数字的含义写的很清楚了。 */ for(int i=1;i&lt;=n;i++)//代表n个礼物。 /* 还能是几个礼物？ */ { cin&gt;&gt;a[i];//输入坐标。 /* 同前。 */ a[i]=min(a[i]-1,1000000-a[i]);//取最小值min。 /* 是当读者完全不知道 min 函数吗？ */ } sort(a+1,a+1+n);//排序后取最大值。 /* 同前。 */ cout&lt;&lt;a[n];//将最大值输出。 /* 同前。 */ return 0;//结束。 /* 不是结束还能是啥？ */ } /* 总结：请不要把读者当完全没学过语言的傻子。 */ 5.3 长代码片段的处理 有很多情况都会导致长代码的产生。长代码片段对题解的观感会造成不小影响。 对于长代码片段，推荐在正文中只贴出关键部分，而将完整代码置于云剪贴板中。 6 正确使用 LaTeX 进入本文的重点了。 这里希望能教会读者正确使用 LaTeX，规避一些错误用法。 6.1 什么东西该放在公式中？ 并不是一切东西都该放在公式中的。滥用公式会导致渲染速度下降，排版混乱等后果。 下面是一个错误示例： 关于 SPFASPFASPFA，它死了。我们应该使用堆优化的 DijkstraDijkstraDijkstra 算法解决单源非负权最短路问题。 正确的写法是： 关于 SPFA，它死了。我们应该使用堆优化的 Dijkstra 算法解决单源非负权最短路问题。 所以什么东西不该放在公式中呢？ 中文一般不要放在 LaTeX 中。 算法名，人名等非公式内容一般不要放在 LaTeX 中。 行内的程序代码（包括程序函数名称，变量类型，完整语句等）应该用行内代码框表示，而不放在公式中。 下面还是一个错误示例： 这是一个错误示例\\huge{\\text{这是一个错误示例}} 这是一个错误示例 还是那句话，要强调的东西没必要弄得那么大。 即使是要放在公式里的东西，对于使用何种字体仍有要求，下面将会讲到。 6.2 正确使用不同的字体 请使用 Roman 体表示函数和运算。 LaTeX 中已经预先定义了很多常用的函数和运算，我们可以直接使用。 下面是一个错误的例子： lcm(x,y)=\\frac{x \\times y}{gcd(x,y)} lcm(x,y)=x×ygcd(x,y)lcm(x,y)=\\frac{x \\times y}{gcd(x,y)} lcm(x,y)=gcd(x,y)x×y​ 正确的写法应该是这样的： \\operatorname{lcm}(x,y)=\\frac{x \\times y}{\\gcd(x,y)} lcm⁡(x,y)=x×ygcd⁡(x,y)\\operatorname{lcm}(x,y)=\\frac{x \\times y}{\\gcd(x,y)} lcm(x,y)=gcd(x,y)x×y​ 又一个错误的例子： f(x,y)=max(x,y) f(x,y)=max(x,y)f(x,y)=max(x,y) f(x,y)=max(x,y) 正确的写法是这样的： f(x,y)=\\max(x,y) f(x,y)=max⁡(x,y)f(x,y)=\\max(x,y) f(x,y)=max(x,y) 简单概括一下： 对于 gcd⁡\\gcdgcd，log⁡\\loglog 这些已经有定义的，请在书写它们的时候在前面直接加一个 \\，例如 gcd⁡\\gcdgcd 请写成 \\gcd。 对于 lcm⁡\\operatorname{lcm}lcm 这样没有定义的，请将它包含在 \\operatorname{} 中。 接下来特别讲一下 mod 运算符。 mod 运算符有三种，\\mod，\\bmod，\\pmod，其中较常用的是 \\bmod 和 \\pmod。下面举例说明它们的区别。 \\bmod 一般用来表示模运算操作： x = a \\bmod b x=a mod bx = a \\bmod b x=amodb \\pmod 则一般用于书写同余方程： 3 \\equiv 8 \\pmod 5 3≡8(mod5)3 \\equiv 8 \\pmod 5 3≡8(mod5) 对于一些字符串常量，使用打字机字体看上去更加美观。 错误的示范： S=abcdefg S=abcdefgS=abcdefg S=abcdefg 正确的写法： S=\\texttt{abcdefg} S=abcdefgS=\\texttt{abcdefg} S=abcdefg 对于非公式内容，应该使用 \\text{}。 错误的示范： f(a) = \\begin{cases} 1 ,&amp; a \\in prime\\\\ 0 ,&amp; otherwise. \\end{cases} f(a)={1,a∈prime0,otherwise.f(a) = \\begin{cases} 1 ,&amp; a \\in prime\\\\ 0 ,&amp; otherwise. \\end{cases} f(a)={1,0,​a∈primeotherwise.​ 正确的写法： f(a) = \\begin{cases} 1 ,&amp; a \\in \\text{prime}\\\\ 0 ,&amp; \\text{otherwise.} \\end{cases} f(a)={1,a∈prime0,otherwise.f(a) = \\begin{cases} 1 ,&amp; a \\in \\text{prime}\\\\ 0 ,&amp; \\text{otherwise.} \\end{cases} f(a)={1,0,​a∈primeotherwise.​ 6.3 行间公式 对于 ∑\\sum∑ ∏\\prod∏ 等巨运算符，放在行内公式会显得比较紧凑。 像这样：∑i=1nai\\sum_{i=1}^n a_i∑i=1n​ai​。 必要的场合请使用行间公式，这样这些巨运算符就不会显得太小，观感也会好不少。 ∑i=1nai\\sum_{i=1}^n a_i i=1∑n​ai​ 6.4 公式不是写代码的地方 我们写的是非常正规的数学公式，因此不要在非代码区域使用任何程序设计语言的表示方式。 下面是一些错误示范： a=x\\%p x++ a==b a &lt;= b a&lt;&lt;1 5e7 a=x%pa=x\\%p a=x%p x++x++ x++ a==ba==b a==b a&lt;=ba &lt;= b a&lt;=b a&lt;&lt;1a&lt;&lt;1 a&lt;&lt;1 5e75e7 5e7 正确的写法是这样的： a=x \\bmod p x \\gets x+1 a=b a \\leq b a \\times 2 5 \\times 10^7 a=x mod pa=x \\bmod p a=xmodp x←x+1x \\gets x+1 x←x+1 a=ba=b a=b a≤ba \\leq b a≤b a×2a \\times 2 a×2 5×1075 \\times 10^7 5×107 注：x←x+1x \\gets x+1x←x+1 表示将 x+1x+1x+1 的值赋给 xxx（其实等号也可以表示赋值的含义，不过在这个场景下这种写法更加严谨）。 这里附一些常用符号的表示方法，以供参考： 小于等于号 a≤ba \\leq ba≤b：\\le 或 \\leq； 大于等于号 a≥ba \\geq ba≥b：\\ge 或 \\geq； 另一种格式的小于等于号 a⩽ba \\leqslant ba⩽b：\\leqslant； 另一种格式的大于等于号 a⩾ba \\geqslant ba⩾b：\\geqslant； 横向省略号（居于排版基线的位置）{1,2,…,n}\\{1, 2, \\ldots, n \\}{1,2,…,n}：\\ldots； 横向省略号（居于排版基线与顶线中间）1+2+⋯+n1 + 2 + \\cdots + n1+2+⋯+n：\\cdots； 叉乘 a×ba \\times ba×b：\\times； 点乘 a⋅ba \\cdot ba⋅b：\\cdot； 整除 a∣ba \\mid ba∣b：\\mid； 更多资料可以在文末的 Reference 部分找到。 6.5 数组的表示 在题解中常常要写到数组，怎样表示比较优美呢？ 我们推荐使用多元函数的形式表示数组。例如：f[i][j] 表示成 f(i,j)f(i,j)f(i,j)。 当然用下标的形式也是不错的选择。像上面的例子可以表示为 fi,jf_{i,j}fi,j​。 6.6 分数 一般情况下，用 \\frac{x}{y} 表示分数 xy\\frac{x}{y}yx​。 但是行内这个分数实在是太小了。 这种情况下我们更建议使用 \\dfrac{x}{y} 表示分数 xy\\dfrac{x}{y}yx​。 （你会发现这个就大不少了） 6.7 特殊符号 不要使用输入法的插入特殊符号功能来插入我们下面要说的特殊符号。 下面是一些特殊符号在 LaTeX 的表示方法。 欧拉函数 φ\\varphiφ：\\varphi（注意不是 \\phi）； 黄金分割数 ϕ\\phiϕ：\\phi； 圆的直径 Φ\\PhiΦ：\\Phi； 莫比乌斯函数 μ\\muμ：\\mu； 圆周率 π\\piπ：\\pi； 空集 ∅\\varnothing∅：\\varnothing（注意不是 \\emptyset）。 更多资料可以在文末 Reference 部分找到。 7 外部链接 在一篇题解中，有一些相关知识并不是题解内容的重点，但又属于理解题解所需的必不可少的内容。虽然在大多数情况下可以假设读者已经了解了相关知识，但在某些特殊情况下，还是需要给出一些外部链接，方便阅读该题解的同学学习。 例如，在 NOIp2001 一元三次方程求解 的题解区中，有好几篇题解都提及了盛金公式，却并没有对其进行任何解释，也没有给出外部链接。这很容易让阅读该题解的人感到疑惑。 后记 网上关于 Markdown 和 LaTeX 的资料其实并不少（在 Reference 部分已经列出），那为什么还要有这篇文章呢？ 本文大多数常见的错误例子都是笔者在题解审核时经常遇到的。举这些错误例子也是希望各位读者引以为戒，在未来的博客撰写中严格遵守格式规范，使题解的排版更加美观。 Reference 如何贡献 - OI-wiki LaTeX 入门 LaTeX 数学公式大全 Markdown 书写风格指南 ","link":"https://doittomorrow.xyz/post/ru-he-zheng-que-de-xie-wen-zhang-zhuan-zai-zi-luo-gu/"},{"title":"[NOIP2014] 解方程","content":"思路 首先我们可以观察到 nnn 和 mmm 与aia_iai​ 相比小的很多，所以我们可以考虑直接暴力求解 但是 aia_iai​ 太大了，所以如果需要直接计算的话需要全程使用高精度算法。 因为高精度算法代码量有大速度又慢我们可依考虑将 aia_iai​ 转化为一个极大的指数取模的结果，因为只有是模数的倍数或者本身就是 000 的数取模才会是 000。 为了避免出现模数的倍数，可以使用两个模数减小概率（像双哈希一样）但是也可以将模数设置的大一点减小几率。可是两个模数码量过大，我们可以直接使用一个大质数（相信出题人不会卡我们的）。 因为题目给出的式子过于的复杂，其实可以使用秦九韶算法进行化简 a0+a1x+a2x2+a3x3+⋯+anxna_0+a_1x+a_2x^2+a_3x^3+\\cdots+a_nx^na0​+a1​x+a2​x2+a3​x3+⋯+an​xn =a0+(a1+a2x+a3x2+⋯+anxn−1)x=a_0+(a_1+a_2x+a_3x^2+\\cdots+a_nx^{n-1})x=a0​+(a1​+a2​x+a3​x2+⋯+an​xn−1)x =a0+(a1+(a2+a3x+⋯+anxn−2)x)x=a_0+(a_1+(a_2+a_3x+\\cdots+a_nx^{n-2})x)x=a0​+(a1​+(a2​+a3​x+⋯+an​xn−2)x)x ⋯\\cdots⋯ =a0+(a1+(a2+(a3+(⋯(an−1+anx)x⋯ )x)x)x=a_0+(a_1+(a_2+(a_3+(\\cdots(a_{n-1}+a_nx)x\\cdots)x)x)x=a0​+(a1​+(a2​+(a3​+(⋯(an−1​+an​x)x⋯)x)x)x 虽说名字叫秦九韶算法，但是其实就是将每一项内的因子提取了出来，即使不化简也一样可以做出来。 在简化之后，就可以从最里层的括号开始，逐层向外递推，码量就少了很多。经过递推，很快的就可以得到表示的值了，时间复杂度为 O(nm)O(nm)O(nm)。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long using namespace std; const int mod=1e9+7; int n,m,a[105]; vector&lt;int&gt; v; inline int read(){ int x=0,f=1; char ch=getchar(); while((ch&lt;'0'||ch&gt;'9')&amp;&amp;ch!='-') ch=getchar(); if(ch=='-') f=-1,ch=getchar(); while(ch&lt;='9'&amp;&amp;ch&gt;='0') x=((x&lt;&lt;1)+(x&lt;&lt;3)+ch-48)%mod,ch=getchar(); return x*f; } void solve(int x){ int cnt=a[n]; for(int i=n;i&gt;=1;i--) cnt=(cnt*x%mod+a[i-1]+mod)%mod; if(cnt==0) v.push_back(x); //储存答案 } signed main(){ n=read(),m=read(); for(int i=0;i&lt;=n;i++) a[i]=read(); for(int i=1;i&lt;=m;i++) solve(i); cout&lt;&lt;v.size()&lt;&lt;endl; for(int i:v) cout&lt;&lt;i&lt;&lt;endl; //将数组v中的元素依次赋值给变量i return 0; } ","link":"https://doittomorrow.xyz/post/noip2014-jie-fang-cheng/"},{"title":"[THUSCH2017] 大魔法师","content":"前期准备 1.熟练的掌握区间修改线段树 2.对矩阵乘法有部分的了解，知道如何使用 3.对卡常十分精通 题目大意 题目给定 nnn 个三元组，每个三元组包含 AAA、BBB、CCC 三个元素，一共进行 mmm 次操作，分别是下面七种之一： 1.令给定区间内，Ai=Ai+BiA_i=A_i+B_iAi​=Ai​+Bi​ 2.令给定区间内，Bi=Bi+CiB_i=B_i+C_iBi​=Bi​+Ci​ 3.令给定区间内，Ci=Ci+AiC_i=C_i+A_iCi​=Ci​+Ai​ 4.令给定区间内，Ai=Ai+vA_i=A_i+vAi​=Ai​+v 5.令给定区间内，Bi=Bi×vB_i=B_i\\times vBi​=Bi​×v 6.令给定区间内，Ci=vC_i=vCi​=v 7.查询区间内每个元素 AAA、BBB、CCC 累加得到的和。 其中 1≤n≤2.5×1051 \\le n \\le 2.5\\times 10^51≤n≤2.5×105，1≤m≤2.5×1051 \\le m \\le 2.5\\times 10^51≤m≤2.5×105 ，元素中每个值对 998244353998244353998244353 取模。 题目时间限制 555 秒！！！ 思路 因为题目要求写一个动态的区间修改和区间最大值，所以自然地就可以想到区间修改线段树。 但是因为这道题目处理的是三元组，所以如果一个一个处理的话，线段树的 lazy 数组的会非常难写。 于是顺理成章的，就应该使用矩阵乘法给线段树进行优化。 每个三元组在运算的过程中都可以看做一个矩阵，而这 777 个操作就只需要推 666 个矩阵并写一个区间求和就结束了。 所以我么需要做的事情就是将这 777 个矩阵推出来，接着将矩阵套到线段树上就可以了。为了便于线段树的书写，我使用的重载运算符（operator），即重新定义符号。 做法 操作 111、222、333 如果你已经做个一些题目的话，那么你应该可以顺理成章的推出后面 333 个式子 [Ai+BiBiCi]=[AiBiCi]×[100110001]\\begin{bmatrix} A_i+B_i &amp; B_i &amp; C_i \\end{bmatrix}= \\begin{bmatrix} A_i &amp; B_i &amp; C_i \\end{bmatrix} \\times \\begin{bmatrix} 1 &amp; 0 &amp;0 \\\\ 1 &amp; 1 &amp; 0\\\\ 0 &amp; 0 &amp;1 \\end{bmatrix} [Ai​+Bi​​Bi​​Ci​​]=[Ai​​Bi​​Ci​​]×⎣⎡​110​010​001​⎦⎤​ [AiBi+CiCi]=[AiBiCi]×[100010011]\\begin{bmatrix} A_i &amp; B_i+C_i &amp; C_i \\end{bmatrix}= \\begin{bmatrix} A_i &amp; B_i &amp; C_i \\end{bmatrix} \\times \\begin{bmatrix} 1 &amp; 0 &amp;0 \\\\ 0 &amp; 1 &amp;0 \\\\ 0 &amp; 1 &amp;1 \\end{bmatrix} [Ai​​Bi​+Ci​​Ci​​]=[Ai​​Bi​​Ci​​]×⎣⎡​100​011​001​⎦⎤​ [AiBiCi+ai]=[AiBiCi]×[101010001]\\begin{bmatrix} A_i &amp; B_i &amp; C_i+a_i \\end{bmatrix}= \\begin{bmatrix} A_i &amp; B_i &amp; C_i \\end{bmatrix} \\times \\begin{bmatrix} 1 &amp; 0 &amp;1 \\\\ 0 &amp; 1 &amp;0 \\\\ 0 &amp; 0 &amp;1 \\end{bmatrix} [Ai​​Bi​​Ci​+ai​​]=[Ai​​Bi​​Ci​​]×⎣⎡​100​010​101​⎦⎤​ 操作444、555、666 现在你会发现这个给定的 vvv 不知道应该塞到哪里了，于是我们就应该添加辅助的维度 可以将原来的 [AiBiCi]\\begin{bmatrix}A_i &amp; B_i &amp;C_i\\end{bmatrix}[Ai​​Bi​​Ci​​] 替换为 [AiBiCi1]\\begin{bmatrix}A_i &amp; B_i &amp;C_i &amp;1\\end{bmatrix}[Ai​​Bi​​Ci​​1​] 辅助增加 [Ai+vBiCi1]=[AiBiCi1]×[100001000010v000]\\begin{bmatrix} A_i+v &amp; B_i &amp; C_i &amp; 1 \\end{bmatrix}= \\begin{bmatrix} A_i &amp; B_i &amp; C_i &amp; 1 \\end{bmatrix} \\times \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp;0 &amp;0\\\\ 0 &amp; 0 &amp;1 &amp;0 \\\\ v &amp; 0 &amp; 0 &amp; 0 \\end{bmatrix} [Ai​+v​Bi​​Ci​​1​]=[Ai​​Bi​​Ci​​1​]×⎣⎢⎢⎡​100v​0100​0010​0000​⎦⎥⎥⎤​ [AiBi×vCi1]=[AiBiCi1]×[10000v0000100000]\\begin{bmatrix} A_i &amp; B_i\\times v &amp; C_i &amp; 1 \\end{bmatrix}= \\begin{bmatrix} A_i &amp; B_i &amp; C_i &amp; 1 \\end{bmatrix} \\times \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; v &amp;0 &amp;0\\\\ 0 &amp; 0 &amp;1 &amp;0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\end{bmatrix} [Ai​​Bi​×v​Ci​​1​]=[Ai​​Bi​​Ci​​1​]×⎣⎢⎢⎡​1000​0v00​0010​0000​⎦⎥⎥⎤​ 操作 777 这个操作其实就可以直接写一个线段树的区间求和就可以了 一些细节 在定义矩阵的结构体里面，应该将矩阵清零而不是直接进行操作。 注意有加法与乘法的线段树 pushdown 处理 lazy 数组时的顺序。 十年 OI 一场空，不开 long long 见祖宗。 记得在每一次运算后都要写取模操作，否则会溢出。 AC Code #include&lt;bits/stdc++.h&gt; #define int long long #define m(s1) memset(s1.a,0,sizeof(s1.a)) const int mod=998244353; const int N=1000005; inline int read(){ int x=0; char ch=getchar(); while(ch&gt;'9'||ch&lt;'0') ch=getchar(); while(ch&lt;='9'&amp;&amp;ch&gt;='0') x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-48,ch=getchar(); return x; } struct node{ int a[3][3],n,m; node(){memset(a,0,sizeof(a));} friend node operator + (const node a,const node b){ node s; s.n=a.n,s.m=a.m; m(s); for(register int i=0;i&lt;a.n;++i) for(register int j=0;j&lt;a.m;++j) s.a[i][j]=(a.a[i][j]+b.a[i][j])%mod; return s; } friend node operator * (const node a,const node b){ node s; s.n=a.n,s.m=b.m; m(s); for(register int i=0;i&lt;a.n;++i) for(register int k=0;k&lt;a.m;++k) for(register int j=0;j&lt;b.m;++j) s.a[i][j]=(s.a[i][j]+a.a[i][k]*b.a[k][j]%mod)%mod; return s; } friend node operator * (const node a,const int b){ node s; s.n=a.n,s.m=a.m; m(s); for(register int i=0;i&lt;a.n;++i) for(register int j=0;j&lt;a.m;++j) s.a[i][j]=a.a[i][j]*b%mod; return s; } }s[8],sum[N],lazy1[N],lazy2[N]; inline void pre(){ s[1].a[0][0]=s[1].a[1][1]=s[1].a[2][2]=s[1].a[1][0]=1; s[1].n=s[1].m=3; s[2].a[0][0]=s[2].a[1][1]=s[2].a[2][2]=s[2].a[2][1]=1; s[2].n=s[2].m=3; s[3].a[0][0]=s[3].a[1][1]=s[3].a[2][2]=s[3].a[0][2]=1; s[3].n=s[3].m=3; s[4].a[0][0]=-1; s[4].n=1,s[4].m=3; s[5].a[0][0]=s[5].a[2][2]=1; s[5].a[1][1]=-1; s[5].n=s[5].m=3; s[6].a[0][0]=s[6].a[1][1]=1; s[6].n=s[6].m=3; s[7].a[0][2]=-1; s[7].n=1,s[7].m=3; } int n,m; inline void updata(int k,int l,int r){ int mid=(l+r)/2; lazy2[k*2]=lazy2[k*2]*lazy2[k]; lazy2[k*2+1]=lazy2[k*2+1]*lazy2[k]; lazy1[k*2]=lazy1[k*2]*lazy2[k]+lazy1[k]; lazy1[k*2+1]=lazy1[k*2+1]*lazy2[k]+lazy1[k]; sum[k*2]=sum[k*2]*lazy2[k]+lazy1[k]*(mid-l+1); sum[k*2+1]=sum[k*2+1]*lazy2[k]+lazy1[k]*(r-mid); m(lazy1[k]),m(lazy2[k]); lazy2[k].a[0][0]=lazy2[k].a[1][1]=lazy2[k].a[2][2]=1; } inline void pre_lazy(int k){ lazy1[k].n=1,lazy1[k].m=3; lazy2[k].n=3,lazy2[k].m=3; lazy2[k].a[0][0]=lazy2[k].a[1][1]=lazy2[k].a[2][2]=1; } void build(int k,int l,int r){ sum[k].n=1,sum[k].m=3; pre_lazy(k); if(l==r){ sum[k].a[0][0]=read(); sum[k].a[0][1]=read(); sum[k].a[0][2]=read(); return; } int mid=(l+r)/2; build(k*2,l,mid); build(k*2+1,mid+1,r); sum[k]=sum[k*2]+sum[k*2+1]; } void up(int k,int l,int r,int ll,int rr,node &amp;v,bool flag){ if(ll&lt;=l&amp;&amp;rr&gt;=r){ if(flag==0) lazy1[k]=lazy1[k]*v,lazy2[k]=lazy2[k]*v,sum[k]=sum[k]*v; else lazy1[k]=lazy1[k]+v,sum[k]=sum[k]+v*(r-l+1); return ; }int mid=(l+r)/2; updata(k,l,r); if(ll&lt;=mid) up(k*2,l,mid,ll,rr,v,flag); if(mid&lt;rr) up(k*2+1,mid+1,r,ll,rr,v,flag); sum[k]=sum[k*2]+sum[k*2+1]; } node ask(int k,int l,int r,int ll,int rr){ if(ll&lt;=l&amp;&amp;rr&gt;=r) return sum[k]; int mid=(l+r)/2; updata(k,l,r); node res; res.n=1,res.m=3; if(ll&lt;=mid) res=ask(k*2,l,mid,ll,rr); if(mid&lt;rr) res=res+ask(k*2+1,mid+1,r,ll,rr); return res; } signed main(){ pre(); n=read(); build(1,1,n); m=read(); for(register int i=1,op,l,r;i&lt;=m;++i){ op=read(),l=read(),r=read(); if(op&lt;=3) up(1,1,n,l,r,s[op],0); if(op==4) s[4].a[0][0]=read(),up(1,1,n,l,r,s[4],1); if(op==5) s[5].a[1][1]=read(),up(1,1,n,l,r,s[5],0); if(op==6) s[7].a[0][2]=read(),up(1,1,n,l,r,s[6],0),up(1,1,n,l,r,s[7],1); if(op==7){ node ans=ask(1,1,n,l,r); printf(&quot;%lld %lld %lld\\n&quot;,ans.a[0][0],ans.a[0][1],ans.a[0][2]); } } return 0; } ","link":"https://doittomorrow.xyz/post/thusch2017-da-mo-fa-shi/"},{"title":"How to ues Dev C++","content":"对于Dev-C++这个&quot;老古董&quot;，合理利用设置去提升它的能力，是非常 important 重要的。 1.打开全警告 方式：工具[T]-&gt;编译选项[C]-&gt;代码生成/优化-&gt;代码警告-&gt;第二个和第三个选Yes 代码里，总是会出现奇奇怪怪的错误（scanf、printf 占位符和参数列表不匹配，if 里把 == 打成 = ，运算符优先级......），面对这种情况，我们需要编译器来帮我们检查。 SO，打开全警告！！！ 这样，当你出现一些奇怪又合法的错误时，编译器会发出警告(但不会终止编译)，所以看警告还是有用的。 2.打开C++11 方式：工具[T]-&gt;编译选项[C]-&gt;代码生成/优化-&gt;代码生成-&gt;语言标准-&gt;ISO C++11 这个老古董居然有 C++11，当会用了 C++11 后，这就非常 nice 了。 3.编译优化 方式：工具[T]-&gt;编译选项[C]-&gt;代码生成/优化-&gt;代码生成-&gt;优化级别-&gt;自己选吧 编译优化就是指编译器修改一些指令的执行方式（不会直接修改源代码）从而使生成的运行程序执行速度更快或内存更小。 关于优化级别： O0：不优化 O1(Low)：在略微占用编译时间的情况下，尝试缩小运行大小并提升运行速度。 O2(Med)：做大量细节优化（常量表达式，无用语句，合并语句...），能提升运行速度。 O3(High)：会尝试破坏运行顺序，做更多的优化，但可能增大运行内存。 Ofast(lighest)：最高级优化，能显著提升STL的速度，但会严重破坏运行顺序，有极小概率出bug。 4.去除结尾空白 方式：工具[T]-&gt;编辑器选项[C]-&gt;基本-&gt;去除结尾空白 在编辑时，这老古董经常给源代码末尾添加一些空格，影响美观，增大源文件大小，更会残害强迫症，手动删又十分麻烦。 SO，打开去除结尾空白后，Dev C++ 会自动删除除鼠标所在行以外的末尾空格，就很nice。 ","link":"https://doittomorrow.xyz/post/how-to-ues-dev-c/"},{"title":"【证明】唯一分解定理","content":"定理内容 每个大于 111 的自然数，要么本身就是质数，要么可以写成 222 个或以上的质数的乘积，而且这个乘积经过排序后仅有一种。 证明 存在性 假设存在大于 111 的自然数不能写成质数的乘积，那么我们将这一类自然数中最小的那个设为 nnn 。 按照一个数的可除性，我们可以将数字分为三类：质数、合数、111。 因为定义，nnn 大于1，所有 nnn 必定属于质数或者合数。 其次，nnn 定然不是质数，因为任意质数 PPP 可以写成质数的乘积，即 P=PP=PP=P 与假设相矛盾。所以，nnn 只能是合数。 因为每个合数都可以写成两个严格小于自身且大于 111 的数的乘积。 不妨设 n=a×bn=a\\times bn=a×b，其中 a,ba,ba,b 都是介于 111 至 nnn 之间的自然数。因为，nnn 是大于 111 的自然数而不能写成质数的乘积中最小的一个，所以 a,ba,ba,b 都可以写成质数的乘积。 从而得出 n=a×bn=a \\times bn=a×b 可以写成质数的乘积。 这与假设相矛盾，因此大于 111 的自然数必然可以写成质数的乘积。 唯一性 假设有大于 111 的自然数可以以多种方式写成一个乘积，那么假设 nnn 是其中最小的一个。 首先 nnn 不是质数，因为质数的分解只有一种方法，即他的本身。所以将 nnn 用两种方法写出 n=p1p2p3...pr=q1q2q3...qsn=p_1p_2p_3...p_r=q_1q_2q_3...q_sn=p1​p2​p3​...pr​=q1​q2​q3​...qs​。 根据定理，质数 p1∣q1q2q3p_1|q_1q_2q_3p1​∣q1​q2​q3​，所以在 q1q2q3⋯qsq_1q_2q_3\\cdots q_sq1​q2​q3​⋯qs​ 中有一个能被 p1p_1p1​ 整除，不妨为q1q_1q1​。 但是，q1q_1q1​ 也是质数，因此 q1=p1q_1=p_1q1​=p1​，所以比 nnn 小的正整数 n′=p2p3⋯prn&#x27;=p_2p_3\\cdots p_rn′=p2​p3​⋯pr​ 也可以写成 q2q3⋯qsq_2q_3\\cdots q_sq2​q3​⋯qs​。 这与 nnn 的最小性矛盾，因此唯一性得证。 ","link":"https://doittomorrow.xyz/post/zheng-ming-wei-yi-fen-jie-ding-li/"},{"title":"Treap 学习笔记","content":"二叉查找树 二叉查找树是一棵有点权的二叉树，具有以下几个特征： 左孩子的权值小于父亲的权值 右孩子的权值大于父亲的权值 中序遍历及从小到大排序 关于这个性质的证明也很简单（因为有智障包不理解，所以才写的）。 因为中序遍历的顺序是左中右，所以第一个访问的一定是最左边的叶子节点，也一定是最小的。同理，第二个节点一定是他的父亲，也就是比他大的数字中最小的。 二叉查找树支持以下几个操作： 插入一个数 删除一个数 找一个数的前驱 找一个数的后继 询问一个数的排名 询问排第几名的数 二叉查找树一棵二叉查找树，所以在它是一棵完全二叉树时，树的度为 log⁡n\\log \\text{n}logn，所以单一操作的时间复杂度应该是 O(log n)\\text{O(log n)}O(log n) 级别的。但是在进行操作时，如果输入的点权单调递增或递减，那么整个数据结构就将由树退化成为链。所以单次操作的时间复杂度最坏为 O(n)\\text{O(n)}O(n) 级别。 需要理解退化的原因就要先知道二叉搜索树是怎么插入的。在插入时，如果插入的值大于这个节点，那么久访问访问右子树，否则访问左子树。如果在访问子树时访问到了不存在的节点，那么久直接在这里新建一个需要添加的节点。 如果输入的节点依次递增，那么在插入的时候就会一直访问左子树，并且一直在左子树新建节点。二叉树就只有右儿子，所以度就成为了 n\\text{n}n。 普通平衡树 为了使这个数据结构平衡，平衡树就应运而生了。Treap 就是平衡树的一种，这个算法就是将树 (Tree) 与堆 (Heap) 相结合了起来。Treap 给每一个节点在维护原来的数值的同时，还添加了一个随机值。但看权值，这是一颗二叉搜索树，但是但看随机值这又是一个堆。 储存 首先我们应该了解一下如何储存一颗平衡树。 因为平衡树的结构是会改变的，所以我们需要储存每一个节点的左孩子与右孩子。因为一个节点可能会多次添加，所以应该使用 cnt 记录以下这个节点出现的个数。为了后面的操作，我们应该还需要定义一个 size 变量记录这个节点及子树的大小。 所以在我们定义的结构体应该是下面这样的： struct node{ int l,r,k,val,cnt,size; }a[N]; updata 在进行修改操作之后，节点的子树大小会发行变化。updata 函数的功能是更新节点的 size 值。 void updata(int u){ a[u].size=a[a[u].l].size+a[a[u].r].size+a[u].cnt; } make 在进行操作时，为了节省空间复杂度，平衡树使用了动态开点。动态开点就是你需要使用一个新节点时就现马上申请一个空间，而不是全部预留好。 int make(int k){ a[++tot].k=k,a[tot].val=rand(); //tot 记录节点个数 a[tot].cnt=a[tot].size=1; return tot; } zig &amp;&amp; zag 既然需要再维护二叉查找树的同时维护平衡树，就需要在不改变平衡树的性质的情况下完成堆所需要的 swap 的操作。所以我们就迎来了平衡树最重要的操作 zig 与 zag。 这是一棵平衡树，其中 1 2 3 为节点 A B C 为子树。 它们满足以下性质：1&gt;A&gt;2&gt;C&gt;3&gt;D 那么如果需要交换 2 3 的位置，那么在不违背其性质的情况下将其改为： 这个过程就是 zig 操作，反之即是 zag 操作。代码实现就是将将操作进行模拟，方法如下： void zig(int &amp;p){ int q=a[p].l; a[p].l=a[q].r,a[q].r=p,p=q; updata(a[p].r),updata(p); } void zag(int &amp;p){ int q=a[p].r; a[p].r=a[q].l,a[q].l=p,p=q; updata(a[p].l),updata(p); } build 因为在平衡树中有旋转操作，所以根节点有可能会在旋转操作中改变位置。为了让根节点的位置保持不变，可以建立两个虚点，并令其优先级远远高于其他的点,永远停留在根节点的位置。 void build(){ make(-INF),make(INF); root=1,a[1].r=2,updata(root); if(a[1].val&lt;a[2].val) zag(root); } insert 在插入操作中，一共有三种操作。反复执行操作三，直至满足操作一或操作二。 操作一：需要处理的节点为 000，意味着这个节点不存在，所以直接新建。 操作二：已经找到车要添加的节点，cnt++。 操作三：需要添加的节点小于或大于这个节点，那么分别访问左节点或右节点。 void insert(int &amp;p,int k){ if(p==0) p=make(k); else{ if(a[p].k==k) a[p].cnt++; if(a[p].k&gt;k){ insert(a[p].l,k); if(a[a[p].l].val&gt;a[p].val) zig(p); }if(a[p].k&lt;k){ insert(a[p].r,k); if(a[a[p].r].val&gt;a[p].val) zag(p); } }updata(p); } 这是以下是一棵平衡树，其中的节点的信息如下： 那么如果需要插入一个名为 X 点权为 505050 随机值为 505050 的节点，那么操作就将是这样的： 首先与 111 比较，发现权值大于 111 ，移动到右子树 222 号节点。 与 222 号节点比较，发现点权小于 222 号节点，那么到左子树 444 号节点。 与 444 号节点进行比较，发现点权大于 444 号节点而且右子树为空，所以新建一个节点。 开始回溯，发现 444 号节点与节点 X\\text{X}X 的随机值不满足小根堆的要求所以执行旋转操作。 在旋转之后，333 号节点的左子树变为节点 X\\text{X}X，X\\text{X}X 的左子树为 444 号节点，444 号节点的左子树为 555 号节点。 再次回溯，发现以上节点均满足小根堆要求，所以操作完成。 del 在删除操作中，同样分为三种操作： 操作一：没有找到这个点就直接返回，不进行修改操作。 操作二：如果这个节点的值大于或者小于要删除的值，那么就继续访问左孩子或者右孩子。 操作三：找到了这个值，如果 cnt 大于 111，那么直接 cnt-- 否则寻找比这个节点大的集合中的最小值。 void del(int &amp;p,int k){ if(p==0) return ; if(a[p].k==k){ if(a[p].cnt&gt;1){ a[p].cnt--; updata(p); return; }if(a[p].l||a[p].r){ if(!a[p].r||a[a[p].l].val) zig(p),del(a[p].r,k); else zag(p),del(a[p].l,k); }else p=0; updata(p); return; }if(a[p].k&gt;k) del(a[p].l,k); else del(a[p].r,k); updata(p); } 这是以下是一棵平衡树，其中的节点的信息如下： 那么如果需要将权值为 707070 的节点删除，那么操作就是这样的： 首先与 111 号节点进行对比，发现权值小于 111 号节点，进入左子树。 与 222 号节点比较，发现权值等于 222 号节点，寻找权值大于 707070 且最小的点。 首先向左走一步，来到 333 号节点。 进入 333 号节点左子树 666 号节点。 666 号节点没有左子树，所以 666 号节点就是要寻找的目标点。 让 666 号节点取代 222 号节点的位置，操作结束。 get_rank get_rank 函数可以获得某个点的排名。在寻找时如果节点在左子树，则这个节点在左子树的排名就是这个节点在这棵子树上的排名。反之，如果这个节点在右子树，那么他的排名就是左子树的大小+根节点的大小+自己在右子树的排名。 int get_rank(int p,int k){ if(p==0) return 0; if(a[p].k==k) return a[a[p].l].size+1; if(a[p].k&gt;k) return get_rank(a[p].l,k); return a[a[p].l].size+a[p].cnt+get_rank(a[p].r,k); } 因为查询的数可能不在树中存在，所以但是 get_rank 的返回值又是默认其存在的，所以将答案设为了函数值−1-1−1。为了避免发生这样的错误，需要在定义一个 find 函数检查是否存在这个节点。 bool find(int p,int x){ if(a[p].k==x) return 0; if(a[p].val==0) return 1; if(a[p].k&gt;x) return find(a[p].l,x); return find(a[p].r,x); } get_key get_key 函数可以获取某个排名的数。当访问到一个节点时，如果这个节点的左子树的大小大于它的排名，那么这个节点就应该在左子树。如果这个排名大于这个节点的大小 + 左子树的大小，那么这个节点就应该在右子树。其他的情况就应该就在这个节点。 int get_key(int p,int rank){ if(p==0) return INF; if(a[a[p].l].size&gt;=rank) return get_key(a[p].l,rank); if(a[a[p].l].size+a[p].cnt&gt;=rank) return a[p].k; return get_key(a[p].r,rank-a[a[p].l].size-a[p].cnt); } get_pr get_pr 函数可以找到一个数的前驱，及比他大的数中最小的一个。因为平衡树满足左孩子 &lt;&lt;&lt; 根节点 &lt;&lt;&lt; 右孩子，所以只需要先走到左孩子，再一直向右走就可以了。 int get_pr(int p,int k){ if(p==0) return-INF; if(a[p].k&gt;=k) return get_pr(a[p].l,k); return max(get_pr(a[p].r,k),a[p].k); } get_ne get_ne 函数可以找到一个数的后驱，及比他小的数中最大的一个。因为平衡树满足左孩子 &lt;&lt;&lt; 根节点 &lt;&lt;&lt; 右孩子，所以只需要先走到右孩子，再一直向左走就可以了。 int get_ne(int p,int k){ if(p==0) return INF; if(a[p].k&lt;=k) return get_ne(a[p].r,k); return min(get_ne(a[p].l,k),a[p].k); } P3369 普通平衡树 这一题就是一道模板题，只需要将前面的操作整合在一起就可以了。 #include&lt;bits/stdc++.h&gt; using namespace std; const int N=100010,INF=1e8; int n; struct Node{int l,r,k,val,cnt,size;}a[N]; int root,tot; void updata(int u){a[u].size=a[a[u].l].size+a[a[u].r].size+a[u].cnt;} int make(int k){ a[++tot].k=k,a[tot].val=rand(); a[tot].cnt=a[tot].size=1; return tot; } void zig(int &amp;p){ int q=a[p].l; a[p].l=a[q].r,a[q].r=p,p=q; updata(a[p].r),updata(p); } void zag(int &amp;p){ int q=a[p].r; a[p].r=a[q].l,a[q].l=p,p=q; updata(a[p].l),updata(p); } void build(){ make(-INF),make(INF); root=1,a[1].r=2,updata(root); if(a[1].val&lt;a[2].val) zag(root); } void insert(int &amp;p,int k){ if(p==0) p=make(k); else{ if(a[p].k==k) a[p].cnt++; if(a[p].k&gt;k){ insert(a[p].l,k); if(a[a[p].l].val&gt;a[p].val) zig(p); }if(a[p].k&lt;k){ insert(a[p].r,k); if(a[a[p].r].val&gt;a[p].val) zag(p); } }updata(p); } void del(int &amp;p,int k){ if(p==0) return ; if(a[p].k==k){ if(a[p].cnt&gt;1){ a[p].cnt--; updata(p); return; }if(a[p].l||a[p].r){ if(!a[p].r||a[a[p].l].val) zig(p),del(a[p].r,k); else zag(p),del(a[p].l,k); }else p=0; updata(p); return; }if(a[p].k&gt;k) del(a[p].l,k); else del(a[p].r,k); updata(p); } int get_rank(int p,int k){ if(p==0) return 0; if(a[p].k==k) return a[a[p].l].size+1; if(a[p].k&gt;k) return get_rank(a[p].l,k); return a[a[p].l].size+a[p].cnt+get_rank(a[p].r,k); } int get_key(int p,int rank){ if(p==0) return INF; if(a[a[p].l].size&gt;=rank) return get_key(a[p].l,rank); if(a[a[p].l].size+a[p].cnt&gt;=rank) return a[p].k; return get_key(a[p].r,rank-a[a[p].l].size-a[p].cnt); } int get_pr(int p,int k){ if(p==0) return-INF; if(a[p].k&gt;=k) return get_pr(a[p].l,k); return max(get_pr(a[p].r,k),a[p].k); } int get_ne(int p,int k){ if(p==0) return INF; if(a[p].k&lt;=k) return get_ne(a[p].r,k); return min(get_ne(a[p].l,k),a[p].k); } bool find(int p,int x){ if(a[p].k==x) return 0; if(a[p].val==0) return 1; if(a[p].k&gt;x) return find(a[p].l,x); return find(a[p].r,x); } int main(){ build(); cin&gt;&gt;n; for(int i=1,op,x;i&lt;=n;i++){ cin&gt;&gt;op&gt;&gt;x; if(op==1) insert(root,x); if(op==2) del(root,x); if(op==3) cout&lt;&lt;get_rank(root,x)+find(root,x)-1; if(op==4) cout&lt;&lt;get_key(root,x+1); if(op==5) cout&lt;&lt;get_pr(root,x); if(op==6) cout&lt;&lt;get_ne(root,x); if(op!=1&amp;&amp;op!=2)cout&lt;&lt;endl; }return 0; } ","link":"https://doittomorrow.xyz/post/treap-xue-xi-bi-ji/"},{"title":"STL常用函数","content":"STL简介 STL 是 Standard Template Library 的简称，中文名称为标准模板库，从根本上讲， 就是各种 STL 容器的集合，容器可以理解为能够实现很多功能的系统的函数。常见的容器有vector，stack，queue，map，set等。 迭代器 迭代器（iterators）是用来访问容器中的元素，类似于指针。迭代器全部包含两个函数： 1.begin() ，返回一个容器开头的迭代器; 2.end() ，返回一个容器末尾的迭代器，但是不包括最后一个元素，而是最后一个元素的下一个地址。 定义： containers &lt;typename&gt;::iterators name; //containers为容器类型，typename为容器内的数据类型，name为迭代器名 string 简介 在 C 语言中，一般使用字符数组char str[ ]来存放字符串，但是操作起来非常麻烦，容易出错。 在 C++中加入了string 类型用来存放字符串，使用起来更加方便。 使用时，需要添加头文件string ，即#include&lt;string&gt;。 定义 string name; // name是变量名 string name2=&quot;abcde&quot;; //可直接赋值 如果需要存放多个字符串，定义string 类型数组： string name [N]; //name[N]可以存放N个字符串。 输入输出 如果要输入输出，只能使用cin和cout。使用cin读入string 类型，就像用scanf()读字符 数组一样，忽略开头的(制表符、换行符、空格），当再次碰到空字符就停止（并不会读取空字符）。 string s; cin&gt;&gt;s; 读入时忽略了空字符，可以将其记作cin读字符串读的是单词。当然，有时我们更希望读取的是句子。 C++ 提供了getline函数以供使用。 getline的原型是：getline(cin,s);，cin指的是读入流，一般情况下我们直接写cin即可，s是字符串，即我们读入的东西要存放的字符串。 string s; getline(cin,s); // getline()读入一行的字符，会舍弃换行符 访问 （1）通过下标访问 对于string 类型的字符串进行访问，与字符数组访问一样，使用下标。如果有string 类型变量名 为s，可直接访问对应字符s[0]，s[1]，s[2]……，s[s.size()-1]，s.size()是用来求string 类型的长度。 （2）通过迭代器访问 string::iterator it; 定义了string 的迭代器it，可以通过*it访问string 中的每一个字符，在常用的STL容器 中，只有vector和string 允许使用v.begin()+5这种迭代器加上整数的写法，等价于访问s[5]。同时，迭代器可以进行自加、自减操作，即it++，++it，it--，--it。 例如： string s=&quot;abcdef&quot;; for(string::iterator it=s.begin();it!=s.end();it++) //输出abcdef cout&lt;&lt;*it&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; for(string::iterator it=s.begin()+3;it!=s.end();it++) //输出def cout&lt;&lt;*it&lt;&lt;&quot; &quot;; s.end()不是取s的尾元素地址，而是尾元素地址的下一个地址，不存储任何元素，不支持it&lt;end()的写法。 运算 ①string 类型可以直接进行加法运算。但是加法是将两个字符串拼接起来。 例如： string s1=&quot;abc&quot;,s2=&quot;efgh&quot;; cout&lt;&lt;s1+s2; //输出abcefgh ② string 类型可以互相进行复制。 例如： string s3; s3=s2; cout&lt;&lt;s3; //输出efgh ③ string 类型可以直接进行关系运算。直接比较大小，按照字典序进行比较。 if(s1&gt;s2) cout&lt;&lt;1; else cout&lt;&lt;0; //最后结果为0，&quot;efgh&quot;字典序大于&quot;abc&quot; //判断是否相等。 s tring s1=&quot;abc&quot;,s2=&quot;abc&quot;; if(s1==s2) cout&lt;&lt;1; //会输出1 常用函数 ① size()和length() 这两个函数都是返回string 类型的长度（字符个数）。时间复杂度 O(1)。 ② clear()和empty() clear()用来清空string 中的所有元素，时间复杂度为O(1) 。 empty()用来判断string 是否为空，是返回true，否则返回false。 例如： string s=&quot;abcde&quot;; cout&lt;&lt;s.size (); //输出5 s.clear(); cout&lt;&lt;s.length(); //输出0 if(s.empty()) cout&lt;&lt;1; else cout&lt;&lt;0; //输出1 ③ insert(pos,s2) 在s下标为pos的元素前插入string 类型s2。 例如： string s=&quot;abcde&quot;,s2=&quot;opq&quot;; s.insert(3,s2); cout&lt;&lt;s; //输出abcopqde ④ erase(pos,len) 删除s中下标为pos开始的len 个字符 。 例如： string s=&quot;abcdefgh&quot;; s.erase(3,3); cout&lt;&lt;s; //输出abcgh ⑤ find(s2) 当s2是s子串时，返回在s中第一次出现的位置，否则，返回string::npos。 例如： string s=&quot;abcdefabcde&quot;,s2=&quot;cde&quot;; if(s.find(s2)!=string::npos) cout&lt;&lt;s.find(s2); //输出2 //s.find(s2,pos)，是在 s 中以 pos 位置起查找 s2 第一次出现的位置，返回值s.find(s2)相同 ⑥ replace(pos,len,s2) 删除s中下标为pos开始的len个字符，并在下标为pos处插入s2。 例如： string s1=&quot;asfgg&quot;,s2=&quot;ad&quot;; s1.replace(1,1,s2); cout&lt;&lt;s1&lt;&lt;endl; //输出aadfgg vector 简介 vector为变成数组，即长度可以根据需要进行改变的数组。在信息学竞赛中，有些题目需要定义很大 的数组，这样会出现&quot;超出内存限制&quot;的错误，使用vector简洁方便，还可以节省空间。 使用时，需要添加头文件vector，即#include&lt;vector&gt;。 定义 vector&lt;typename&gt; name; 以上定义相当于定义了一个一维数组name[size]，只是size不确定，大小可以根据需要而变化。 其中 tyepename为基本类型，如int、double、char、结构体等，也可以是STL的容器，如string 、queue，vector等。 例如： vector&lt;int&gt; a; vector&lt;double&gt; score; vector&lt;node&gt; stu; //node为已经定义了得结构体 但是，如果typename也是一个 STL 容器，那么定义时，需要在两个 &quot;&gt;&quot;之间加上一个空格，因为&quot;&gt;&gt;&quot;会被当作右移运算，从而导致编译出错，例如： vector&lt;int&gt; a[100]; //定义一个一维长度固定为100，另一维不确定的二维数组a[100][size] vector&lt;vector&lt;int&gt; &gt; a; //定义一个两维都可变的二维数组a[size][size] 常用函数 （1）push_back(x) 在vector数组后面添加一个元素x，下标从0开始，时间复杂度为 O(1) 。 （2）size() 如果是一维数组，size()获得vector中元素的个数;如果是二维数组，size()获得vector中 的第二维的元素个数，时间复杂度为 O(1)。 （3）pop_back() 删除vector的末尾元素，时间复杂度为O(1) 。 （4）clear() 清空vector中的元素，时间复杂度为O(n) ，n 为vector中元素的个数。 （5）insert(it,x) 在vector 迭代器 it 处插入一个元素 x ， x 后的元素后移，时间复杂度为**O(n) . （6）erase(it)、erase(first,last) 删除vector中的元素元素。erase(it)，删除迭代器it处的元素; erase(first,last) ，删除左闭右开区间内的所以元素。 例如： vector&lt;int&gt; v; for(int i=1;i&lt;=5;i++) v.push_back(i); //数组元素为1 2 3 4 5 for(int i=0;i&lt;v.size();i++) cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;; //输出1 2 3 4 5 cout&lt;&lt;endl; v.pop_back(); for(int i=0;i&lt;v.size();i++) cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;; //输出1 2 3 4 cout&lt;&lt;endl; v.insert(v.begin()+2,10); //将10插入到v[2]处 for(int i=0;i&lt;v.size();i++) cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;; //输出1 2 10 3 4 cout&lt;&lt;endl; v.erase(v.begin()+1,v.begin()+3); //删除v[1],v[2], for(int i=0;i&lt;v.size();i++) cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;; //输出1 3 4 cout&lt;&lt;endl; v.clear(); cout&lt;&lt;v.size(); //输出0 访问 访问vector中的元素一般有两种方式。 （1）通过下标进行访问，对于容器vector v，可以使用v[i]来访问第i个元素。 （2）通过迭代器访问 定义： vector&lt;int&gt;::iterator it; 定义一个迭代器it，通过*it访问int类型的vector中的元素。 在常用的容器中，只有vector和string 允许使用v.begin()+5这种迭代器加上整数的写法。 vector&lt;int&gt; v; for(int i=1;i&lt;=5;i++) v.push_back(i); //数组元素为1 2 3 4 5 vector&lt;int&gt;::iterator it=v.begin(); for(int i=0;i&lt;v.size();i++) cout&lt;&lt;(it+i)&lt;&lt;&quot; &quot;; //输出1 2 3 4 5 同时，迭代器可以进行自加、自减操作，即it++，++it，it--，--it。 vector&lt;int&gt; v; for(int i=1;i&lt;=5;i++) v.push_back(i); //数组元素为1 2 3 4 5 for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; //输出1 2 3 4 5 stack 简介 stack翻译为栈，实现先进后出的容器。 使用时，需要添加头文件stack，即#include&lt;stack&gt;。 定义 stack&lt;typename&gt; name; 例如： stack&lt;int&gt; s; //定义一个int类型的栈s 常用函数 （1）push(x) 将元素 x 压栈，时间复杂度为 O(1) 。 （2）top() 获取栈顶元素，时间复杂度为O(1) 。 （3）pop() 弹出栈顶元素，时间复杂度为O(1) 。 （4）empty() 检测stack()是否为空，空返回true，否则返回false，时间复杂度为 。在使用top()和pop()之前，须用q.empty()判断是否为空，否则可能因为栈空出现错误。 （5）size() 返回stack内的元素个数，时间复杂度为 O(1)。 例如： stack&lt;int&gt; s; for(int i=1;i&lt;=5;i++) s.push(i); //栈元素为1 2 3 4 5 s.pop(); //删除栈顶元素5 cout&lt;&lt;s.top()&lt;&lt;endl; //输出4 cout&lt;&lt;s.size()&lt;&lt;endl; //输出4 while(!s.empty()) { cout&lt;&lt;s.top(); //输出 4 3 2 1 s.pop(); } queue 简介 queue翻译为队列，是一个&quot;先进先出&quot;的容器。 使用时，需要添加头文件queue，即#include &lt;queue&gt;。 定义 queue &lt;typename&gt; name; // name是变量名 例如： queue &lt;int&gt; q; //定义一个int类型，名为q的队列 常用函数 （1）push(x) 将x入队，时间复杂度O(1) 。 （2）front()和back() 分别用来访问队首和队尾元素，时间复杂度O(1) 。 （3）pop() 删除队首元素。 (4）empty() 用来检查队首是否为空，返回true或者false，时间复杂度 。在使用front()和pop()之前，须用empty()判断是否为空，否则可能因为队空出现错误。 （5）size() 返回中的元素个数，时间复杂度O(1) 。 priority_queue 简介 priority_queue翻译为优先队列，其底层是用堆实现的。 在优先队列中，任何时刻，队首元素一定是当前优先级最高（值最大）的一个（大根堆），也可以是值 最小的一个（小根堆）。你可以不断往队列中添加或删除优先级不同的元素，每次操作队列都会自动调 整，始终保证队首优先级最高。 优先队列的优先级设置一般是数字越大优先级越大，对于char，字典序越大优先级越大。 使用时，需要添加头文件queue，即#include &lt;queue&gt;。 定义 priority_queue &lt;typename&gt; name; 例如： priority_queue &lt;int&gt; q; //定义一个int类型，名为q的优先队列： 这样定义的是一个大根堆，它的原型其实是： priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q; 尖括号中多了两个参数，vector&lt;int&gt;，表示的是承载底层数据结构——堆的容器，类型与第一个参 数一致; less ，是对第一个参数的比较类，表示数字越大优先级越大（大根堆），而如果用 greater ，则表示数字越小优先级越大。 因此，定义大根堆有两种方法，这两种方法是等价的： priority_queue &lt;int&gt; q; priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q; 定义小根堆： priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; 注意，最后的&quot;&gt;&gt;&quot; ，两个&quot;&gt;&quot;之间是有空格的，没有空格会被当作右移运算，会出现编译错误。 常用函数 （1）push(x) 将x入队，加入后，会自动调整整个优先 队列内部结构，保证队首（堆顶）优先级最高。 （2）top() 获取队首元素（堆顶元素），时间复杂度 O(1)。 （3）pop() 删除队首元素（堆顶元素），加入后，会自 动调整整个优先队列内部结构，保证队首（堆顶）优先级最高。 （4）empty() 用来检查队首是否为空，返回true或者false，时间复杂度 O(1) 。在使用top()和pop()之前，须用empty()判断是否为空，否则可能因为队空出现错误。 例如： priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; //定义小根堆 q.push(4); q.push(6); q.push(3); q.push(9); if(!q.empty()) cout&lt;&lt;q.top(); //输出3 q.pop(); if(!q.empty()) cout&lt;&lt;q.top(); //输出4 结构体 如果优先队列的元素是结构体。 现在读入若干学生的语文、数学成绩和姓名，按照按语文从大到小排序，语文相同按数学大到小排序， 数学相同，按名字字典序排序。 也可以使用pair，更方便。 例如： struct stu { int chinese; int math; string name; bool operator&lt;(const stu &amp;x) const{ if(chinese&lt;x.chinese) return 1; //语文大的在前,和sort相反 if(chinese&gt;x.chinese) return 0; if(math&lt;x.math) return 1; //语文相等，数学大的在前 if(math&gt;x.math) return 0; if(name&gt;x.name) return 1; //语文数学都相等，字典序大的在前 return 0; } }; priority_queue&lt;stu&gt; q; int main() { stu a; a.chinese=90;a.math=80;a.name=&quot;abc&quot;; q.push(a); //放入 a.chinese=90;a.math=85;a.name=&quot;xyz&quot;; q.push(a); a.chinese=90;a.math=85;a.name=&quot;yyy&quot;; q.push(a); a.chinese=92;a.math=85;a.name=&quot;bcd&quot;; q.push(a); a=q.top(); cout&lt;&lt;a.chinese&lt;&lt;&quot; &quot;&lt;&lt;a.math&lt;&lt;&quot; &quot;&lt;&lt;a.name&lt;&lt;endl; //输出 92 85 bcd q.pop(); //删除第一个 a=q.top(); cout&lt;&lt;a.chinese&lt;&lt;&quot; &quot;&lt;&lt;a.math&lt;&lt;&quot; &quot;&lt;&lt;a.name&lt;&lt;endl; //输出 90 85 xyz return 0; } pair pair是二元结构体，将两个元素捆绑在一起，相当于： struct pair { typename1 first; typename2 second; } 使用时，需要添加头文件#include&lt;utility&gt;。 定义 pair有两个参数，可以是任意基本类型或容器。 pair &lt;typename1,typename2&gt; name; 初始化 pair使用first和second访问第一，第二个元素。 pair有三种初始化的方式，如下： pair&lt;string,int&gt; p(&quot;abc&quot;,1); //初始化1 cout&lt;&lt;p.first&lt;&lt;&quot; &quot;&lt;&lt;p.second&lt;&lt;endl; //输出abc 1 p.first=&quot;bcd&quot;; //初始化2 p.second=5; cout&lt;&lt;p.first&lt;&lt;&quot; &quot;&lt;&lt;p.second&lt;&lt;endl; //输出bcd 5 p=make_pair(&quot;xyz&quot;,9); //初始化3 cout&lt;&lt;p.first&lt;&lt;&quot; &quot;&lt;&lt;p.second&lt;&lt;endl; //输出xyz 9 如果有三个元素，也可以用pair实现： pair&lt;int,pair&lt;int,int&gt; &gt; p[100]; //&gt; &gt;中间有空格，否则会被当作位移运算 p[1].first=1; p[1].second.first=5; p[1].second.second=2; cout&lt;&lt;p[1].first&lt;&lt;&quot; &quot;&lt;&lt;p[1].second.second; //输出1 2 pair可以直接做比较。比较规则是先以first的大小作为标准，只有当first相等时才去判断second的大小。 例如： pair&lt;int,int&gt; p1(5,10); pair&lt;int,int&gt; p2(5,15); pair&lt;int,int&gt; p3(10,5); if(p1&lt;p3) cout&lt;&lt;&quot;p1&lt;p3&quot;&lt;&lt;endl; //输出p1&lt;p3 if(p1&lt;p2) cout&lt;&lt;&quot;p1&lt;p2&quot;&lt;&lt;endl; //输出p1&lt;p2 if(p1&lt;=p3) cout&lt;&lt;&quot;p1&lt;=p3&quot;&lt;&lt;endl; //输出p1&lt;=p3make&lt;int,int&gt; p1(5,10); map 简介 map翻译为映射。其实，数组就是一种映射。int a[100]定义了一个int到int的映射，a[5]=25，把5映射到25。数组总是将int类型映射到其他类型。如果要将string 类型映射到int类型，数组就很不方便，此时可以使用map，map可以将任意基本类型（包括STL容器）映射 到任意基本类型（包括STL类型）。 map常用情形： 1)建立字符(串)与整数之间的映射 2)判断大整数(几千位)或者其他类型数据是否存在，可以将map当布尔数组使用，实现类似哈希表的功 能。 3)字符串与字符串的映射。 使用时，需要添加头文件map，即#include&lt;map&gt;。 定义 map&lt;typename1,typename2&gt; name; typename1是映射前的类型(键 )，typename2是映射后的类型（value值 ），name为映射名称。 普通int 数组a就是：map&lt;int,int&gt; a; 字符串映射到整型，必须使用string ，不能使用char：map&lt;string,int&gt; a;。 访问 （1）通过下标进行访问 下标访问就像访问普通数组元素一样，如定义:map&lt;char,int&gt; mp，就可以通过mp['c']访问对应 元素，如mp['c']=24。 （2）通过迭代器进行访问 map的每一对映射都有两个typename，所以用it-&gt;first访问键，使用it-&gt;second来访问值。 赋值 map有两种种输入方式： （1）用insert函数插入pair数据，pair可以作为map的键值对来插入。 map&lt;string,int&gt; mp; mp.insert(pair&lt;string,int&gt;(&quot;xyz&quot;,1)); mp.insert(pair&lt;string,int&gt;(&quot;def&quot;,2)); mp.insert(pair&lt;string,int&gt;(&quot;abc&quot;,3)); for(map&lt;string,int&gt;::iterator it=mp.begin();it!=mp.end();it++) cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;&quot; &quot;; //输出abc 3 def 2 xyz 1 可以看出，map建立映射后，会自动实现按键从小到大排序，这是因为map内部使用红黑树实现的 （set也是如此）。 （2）用数组进行插入 map&lt;string,int&gt; mp; mp[&quot;abc&quot;]=1; mp[&quot;def&quot;]=2; mp[&quot;xyz&quot;]=3; for(map&lt;string,int&gt;::iterator it=mp.begin();it!=mp.end();it++) cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;&quot; &quot;; //输出abc 1 def 2 xyz 3 但是它们是有区别的，用insert函数插入数据，在数据的插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入不了数据的，但是用数组方式就不同了，它可以覆盖以 前该关键字对应的值。 常用函数 （1）find(key) 返回键为key的映射的迭代器，如果未找到，返回end()的迭代器 例如： map&lt;int,int&gt; mp; mp.insert(pair&lt;int,int&gt;(1,10)); if(mp.find(2)==mp.end()) cout&lt;&lt;&quot;Not exist&quot;; //输出Not exist （2）size() 返回map中映射的对数，时间复杂度为O(1) 。 （3）erase(it)和erase(first,last) erase(it)删除迭代器it的元素，也可以用erase(key)， 为要删除映射的键。 erase(first,last)，删除左闭右开区间(first,last] ，first 为起始迭代器，last 为末尾迭代器的下一个地址。 （4）clear() 清空map，时间复杂度为 O(n)。 map&lt;string,int&gt; mp; mp[&quot;xyz&quot;]=1; mp[&quot;def&quot;]=2; mp[&quot;abc&quot;]=3; cout&lt;&lt;mp.size()&lt;&lt;endl; //输出3 map&lt;string,int&gt;::iterator it=mp.find(&quot;xyz&quot;); cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl; //输出xyz 1 mp.erase(it); //将这句话与find可以和合并成一句话mp.erase(&quot;xyz&quot;)，时间复杂度相同 for(map&lt;string,int&gt;::iterator it=mp.begin();it!=mp.end();it++) cout&lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;&quot; &quot;; //输出abc 3 def 2 it=mp.find(&quot;abc&quot;); mp.erase(it,mp.end()); cout&lt;&lt;mp.size()&lt;&lt;endl; //输出0 set 简介 set翻译为集合，是一个内部自动有序切且不含重复元素的容器。set的主要作用就是**自动去重并按 升序排序 **，因此遇到不方便开数组的情况，比如元素较大或类型不是int，可以是一个set解决。set内部也是使用红黑树实现的。 使用时，添加set头文件，即#include&lt;set&gt;。 定义 set&lt;typename&gt; name; typename 可以是任意类型或容器，name是集合名称。 set&lt;int&gt; st; //定义int的集合st set&lt;int&gt; st[100]; //定义int的100个集合st[0],st[1]...st[99] 访问 set只能通过迭代器访问。 set&lt;typename&gt;::iterator it; 通过*it访问set中元素。 常用函数 （1）inset(x) 将x插入到set中，并自动排序去重。 如果未找到，返回end()的迭代器。 例如： set&lt;int&gt; s; s.insert(10); if(s.find(5) != s.end()) cout&lt;&lt;&quot;exist&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;Not exist&quot;&lt;&lt;endl; //输出Not exist （2）size() 返回set中的个数，时间复杂度为O(1) 。 （3）find(x) 返回set中对应值x的迭代器。 ** (4)clear** 清空set中的元素，时间复杂度为O(n) 。 （5）erase(it)和erase(first,last) erase(it)删除迭代器it的元素，时间复杂度为 O(1)，也可以用erase(value)，value为要删除 元素的值。 erase(first,last)，删除左闭右开区间[first,last) ， first为起始迭代器， last为末尾迭代器的下一个地址，时间复杂度为 O(first-last)。 set&lt;int&gt; st; for(int i=5;i&lt;=10;i++) st.insert(i); cout&lt;&lt;(st.find(2))&lt;&lt;endl; //输出6 set&lt;int&gt;::iterator it=st.find(8); st.erase(it,st.end()); //删除8 9 10 for(it=st.begin();it!=st.end();it++) cout&lt;&lt;*it&lt;&lt;&quot; &quot;; //输出5 6 7 multiset 简介 multiset与set类似，区别是multiset能够保存重复的元素。 定义 multiset&lt;typename&gt; name; 常用函数 multiset容器和set容器有相同的成员函数，但是因为multiset可以保存重复元素，有些函数的 表现会有些不同。和set容器中的成员函数表现不同的是： （1）insert() 总是可以成功执行。当插入单个元素时，返回的迭代器指向插入的元素。 （2）find() 会返回和参数匹配的第一个元素的迭代器，如果都不匹配，则返回容器的结束迭代器。 （3）count() 返回和参数匹配的元素的个数。 algorithm 简介 algorithm翻译为算法，提供了大量函数 1.max(x,y)，min(x,y)，abs(x)，swap(x,y) max(x,y)，min(x,y)返回较大值和较小值，可以是整型，也可以是浮点型。 abs(x)返回x的绝对值，x必须是整数。如果要求浮点数绝对值，可以使用math头文件下的fabs(x) swap(x,y)用来交换x和y的值。 2.next_permutation() 求一个序列中全排列的下一个序列。例如123的全排列为：123 ，132 ，213 ，312 ，321 ，231 ， 的 下一个排列就是 321. 基本格式：next_permutation(起始元素地址，结束元素地址的下一个地址) int a[10]; a[1]=1;a[2]=2;a[3]=3; do{ cout&lt;&lt;a[1]&lt;&lt;&quot; &quot;&lt;&lt;a[2]&lt;&lt;&quot; &quot;&lt;&lt;a[3]&lt;&lt;endl; }while(next_permutation(a+1,a+4)); //a[1],a[2],a[3]的排列 输出： 1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 3.sort() sort是实现排序的函数。 （1）sort的基本格式： sort( 起始元素地址，结束元素地址的下一个地址，比较函数); 比较函数缺少会默认对区间元素递增排序。 bool cmp(int x,int y) //定义比较函数，string、double、char类型均可 { if(x&gt;y) return 1; //如果a&gt;b成立，a放前面 return 0; //否则放在后面 } int main() { int a[6]={4,5,9,-2,5,-5}; sort(a,a+4); //a[0]~a[3]从小到大排序 for(int i=0;i&lt;6;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; //输出 -2 4 5 9 5 -5 cout&lt;&lt;endl; sort(a+2,a+6,cmp); //a[2]~a[5]从大到小排序 for(int i=0;i&lt;6;i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;; //输出-2 4 9 5 5 -5 return 0; } （2）结构体sort 现在对学生成绩排序，按语文从大到小排序，语文相同按数学大到小排序，数学相同，按名字字典序排序。 struct stu //结构体 { int chinese; int math; string name; }a[100]; bool cmp(stu x,stu y) //结构体类型 { if(x.chinese&gt;y.chinese) return 1; //语文大的在前 if(x.chinese&lt;y.chinese) return 0; if(x.math&gt;y.math) return 1; //语文相等，数学大的在前 if(x.math&lt;y.math) return 0; if(x.name&gt;y.name) return 1; //语文数学都相等，字典序大的在前 return 0; } int main() { for(int i=1;i&lt;=5;i++) cin&gt;&gt;a[i].chinese&gt;&gt;a[i].math&gt;&gt;a[i].name; sort(a+1,a+6,cmp); for(int i=1;i&lt;=5;i++) cout&lt;&lt;a[i].chinese&lt;&lt;&quot; &quot;&lt;&lt;a[i].math&lt;&lt;&quot; &quot;&lt;&lt;a[i].name&lt;&lt;endl; return 0; } 输入： 90 80 abc 90 85 xyz 92 85 ppt 92 85 bcd 100 53 hij 输出： 100 53 hij 92 85 ppt 92 85 bcd 90 85 xyz 90 80 abc （3）容器sort STL中的容器中，只有vector、string 可以使用sort()。其他类型map、set等，其中元素 本身就是有序的，无法使用。 bool cmp(int x,int y) //结构体类型 { if(x&gt;y) return 1; return 0; } int main() { vector&lt;int&gt; v; for(int i=1;i&lt;=5;i++) //输入 7 9 0 2 1 { int t; cin&gt;&gt;t; v.push_back(t); } sort(v.begin(),v.end(),cmp); for(int i=0;i&lt;v.size();i++) cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;; //输出9 7 2 1 0 return 0; } 4.lower_bound(first,last,val)和upper_bound(first,last,val) lower_bound(first,last,val)用来寻找一个有序(从小到大)数组或者容器[first,last)中，第一个 值大于或等于val的位置。如果是数组，返回该位置指针，如果是容器，返回该位置的迭代器。 upper_bound(first,last,val)用来寻找一个有序数组或容器 [first,last)中，第一个值大于val的位置。如果是数组，返回该位置指针，如果是容器，返回该位置的迭代器。 如果数组或者容器中没有需要寻找的元素，则上面两个函数的返回值均为可以插入该位置的指针或迭代器 。 例如： int a[10]={1,2,2,3,3,3,5,5,5,5}; int b[10]={5,5,5,5,3,3,3,2,2,1}; int *t=lower_bound(a,a+10,2); cout&lt;&lt;t&lt;&lt;endl; //t为找到元素的地址 cout&lt;&lt;t-a&lt;&lt;endl; //输出1 //a为a[0]的地址，数组存储使用连续的地址，t-a即数组中第几个元素 //a+2为a[2]的地址 t=upper_bound(a+2,a+10,2); // t为找到元素的地址 cout&lt;&lt;t-(a+2)&lt;&lt;endl; //输出3 cout&lt;&lt;upper_bound(a,a+10,3)-a&lt;&lt;endl; //也可以不指针，输出6 ","link":"https://doittomorrow.xyz/post/stl-chang-yong-han-shu/"},{"title":"一些 C++ 的卡常技巧","content":"是的，这篇文章的主要内容非常好懂，相信各位同学也十分感兴趣 毕竟哪位OIer不想自己的代码跑得飞快呢？ 那么我们就进入正题吧！ First 众所周知，一份代码里面必然会有很多循环打表的话当我没说，而循环自然是十分占时间的。 所以我们要做的就十分清楚了：加速循环！ 1. 把 int 改成 register int register int 表示使用cpu内部寄存器（寄存器为中央处理器内的组成部分，是有限存贮容量的高速存贮部件）的变量。 而平时的 int 是把变量放在内存中，存到寄存器中可以加快变量的读写速度。 2. 把 i++ 改成 ++i i++ 是先计算再储存,而 ++i 是先储存再计算。 一般情况，两者的效率相比之下，自然是 ++i 更胜一筹。 Second 函数是很常用的一个东西，很大意义上，它可以看出我们做题的思路是否明晰。 如果你想要让你的代码的运行速度更快，可以试着在你的函数类型前面加上 inline。 inline 可以把函数指定为内联函数，这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。 Third 俗话说得好，“十年OI一场空，不开 long long 见祖宗”。 但是long long 占用的二进制位是 int 的两倍，所以计算机处理 long long 类型的变量的时候花费的时间会更长。 Forth 有些题的输入和输出十分毒瘤，动不动就几十万几百万的数据能轻松把你的时间拉特别高。 所以，快读快写出现了，以下为快读快写代码，可直接食用。 char ch; inline void read(int &amp;x) { while((ch=getchar())&lt;48||ch&gt;57); x=ch^48; while((ch=getchar())&lt;58&amp;&amp;ch&gt;47) x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); } Fifth 因为位运算是直接对二进制的位进行运算，而且计算机处理位运算和三目运算符要比正常计算快。 所以在写一些代码时，可以这样优化： max(x,y) -&gt; x&gt;y?x:y min(x,y) -&gt; x&lt;y?x:y x%2 -&gt; x&amp;1 x/2 -&gt; x&gt;&gt;1 x*2 -&gt; x&lt;&lt;1; Sixth 因为 using namespace std 的功能仅仅是让你在调用标准函数库的时候不在前面加上 std::，所以为了让代码更快完全可以将他删掉。 但是因为每一次都要写 std:: 太麻烦，我在这么干的时候一般都会 define _ std::。 ","link":"https://doittomorrow.xyz/post/guan-yu-zhe-shi-wo-di-yi-ci-yong-you-zi-ji-de-wang-zhan-zhe-jian-shi/"}]}